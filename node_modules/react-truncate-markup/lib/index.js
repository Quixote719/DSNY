'use strict';

exports.__esModule = true;
exports.default = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _class, _temp2;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _lineHeight = require('line-height');

var _lineHeight2 = _interopRequireDefault(_lineHeight);

var _resizeObserverPolyfill = require('resize-observer-polyfill');

var _resizeObserverPolyfill2 = _interopRequireDefault(_resizeObserverPolyfill);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SPLIT = {
  LEFT: true,
  RIGHT: false
};

var cloneWithChildren = function cloneWithChildren(node, children, isRootEl) {
  return _extends({}, node, {
    props: _extends({}, node.props, {
      style: _extends({}, node.props.style, !isRootEl ? {
        display: (node.props.style || {}).display || 'inline'
      } : {}),
      children: children
    })
  });
};

var TruncateMarkup = (_temp2 = _class = function (_React$Component) {
  _inherits(TruncateMarkup, _React$Component);

  function TruncateMarkup() {
    var _temp, _this, _ret;

    _classCallCheck(this, TruncateMarkup);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = {
      text: _this._childrenElementWithRef(_this.props.children)
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  TruncateMarkup.prototype.componentDidMount = function componentDidMount() {
    var _this2 = this;

    this._origText = this.state.text;
    this._splitDirectionSeq = [];
    this._shouldTruncate = true;

    // get the computed line-height of the parent element
    // it'll be used for determining whether the text fits the container or not
    this._lineHeight = this.props.lineHeight || (0, _lineHeight2.default)(this.el);

    this._truncate();

    /* Wrapper element resize handing */
    var initialRender = true;

    this.resizeObserver = new _resizeObserverPolyfill2.default(function () {
      if (initialRender) {
        // ResizeObserer cb is called on initial render too so we are skipping here
        initialRender = false;
      } else {
        // wrapper element has been resized, recalculating with the original text
        _this2.setState({
          text: _this2._origText
        }, function () {
          _this2._shouldTruncate = true;
          _this2._truncate();
        });
      }
    });

    this.resizeObserver.observe(this.el);
  };

  TruncateMarkup.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    var _this3 = this;

    this.setState({
      text: this._childrenElementWithRef(nextProps.children)
    }, function () {
      _this3._origText = _this3.state.text;
      _this3._lineHeight = nextProps.lineHeight || (0, _lineHeight2.default)(_this3.el);
      _this3._shouldTruncate = true;
      _this3._truncate();
    });
  };

  TruncateMarkup.prototype.componentDidUpdate = function componentDidUpdate() {
    if (this._shouldTruncate === false) {
      return;
    }

    if (this._endFound) {
      // we've found the end where we cannot split the text further
      // that means we've already found the max subtree that fits the container
      // so we are rendering that
      if (this.state.text !== this._latestThatFits) {
        /* eslint-disable react/no-did-update-set-state */
        this.setState({
          text: this._latestThatFits
        });
        /* eslint-enable */
      } else if (this.el && this.el.clientWidth !== this._clientWidth) {
        // edge case - scrollbar (dis?)appearing might mess up the container width
        // causing strings that would normally fit on X lines to suddenly take up X+1 lines
        // ugly fix - recalculate again
        this._truncateOriginalText();
      }

      return;
    }

    if (this._splitDirectionSeq.length) {
      if (this._fits()) {
        this._latestThatFits = this.state.text;
        this._clientWidth = this.el.clientWidth;
        // we've found a subtree that fits the container
        // but we need to check if we didn't cut too much of it off
        // so we are changing the last splitting decision from splitting and going left
        // to splitting and going right
        this._splitDirectionSeq.splice(this._splitDirectionSeq.length - 1, 1, SPLIT.RIGHT, SPLIT.LEFT);
      } else {
        this._splitDirectionSeq.push(SPLIT.LEFT);
      }

      this._tryToFit(this._origText, this._splitDirectionSeq);
    }
  };

  TruncateMarkup.prototype.componentWillUnmount = function componentWillUnmount() {
    if (this.resizeObserver) {
      this.resizeObserver.disconnect();
    }

    this._lineHeight = null;
    this._origText = null;
    this._latestThatFits = null;
    this._splitDirectionSeq = [];
  };

  TruncateMarkup.prototype._truncate = function _truncate() {
    if (this._fits()) {
      // the whole text fits on the first try, no need to do anything else
      this._shouldTruncate = false;

      return;
    }

    this._latestThatFits = null;

    this._truncateOriginalText();
  };

  TruncateMarkup.prototype._childrenElementWithRef = function _childrenElementWithRef(children) {
    var _this4 = this;

    var child = _react2.default.Children.only(children);

    return _react2.default.cloneElement(child, { ref: function ref(el) {
        return _this4.el = el;
      } });
  };

  TruncateMarkup.prototype._truncateOriginalText = function _truncateOriginalText() {
    this._endFound = false;
    this._splitDirectionSeq = [SPLIT.LEFT];

    this._tryToFit(this._origText, this._splitDirectionSeq);
  };

  /**
   * Splits rootEl based on instructions and updates React's state with the returned element
   * After React rerenders the new text, we'll check if the new text fits in componentDidUpdate
   * @param  {ReactElement} rootEl - the original children element
   * @param  {Array} splitDirections - list of SPLIT.RIGHT/LEFT instructions
   */


  TruncateMarkup.prototype._tryToFit = function _tryToFit(rootEl, splitDirections) {
    if (!rootEl.props.children) {
      // no markup in container
      return;
    }

    var newRootEl = this._split(rootEl, splitDirections, /* isRootEl */true);

    var ellipsis = typeof this.props.ellipsis === 'function' ? this.props.ellipsis(newRootEl) : _typeof(this.props.ellipsis) === 'object' ? _react2.default.cloneElement(this.props.ellipsis, { key: 'ellipsis' }) : this.props.ellipsis;

    var newChildren = newRootEl.props.children;
    var newChildrenWithEllipsis = Array.isArray(newChildren) ? [].concat(newChildren, [ellipsis]) : [newChildren, ellipsis];

    this.setState({
      text: _extends({}, newRootEl, {
        props: _extends({}, newRootEl.props, {
          style: _extends({
            wordWrap: 'break-word'
          }, newRootEl.props.style),
          children: newChildrenWithEllipsis
        })
      })
    });
  };

  /**
   * Splits JSX node based on its type
   * @param  {null|string|Array|Object} node - JSX node
   * @param  {Array} splitDirections - list of SPLIT.RIGHT/LEFT instructions
   * @return {null|string|Array|Object} - split JSX node
   */


  TruncateMarkup.prototype._split = function _split(node, splitDirections) {
    var isRoot = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

    if (!node) {
      return node;
    } else if (typeof node === 'string') {
      return this._splitString(node, splitDirections);
    } else if (Array.isArray(node)) {
      return this._splitArray(node, splitDirections);
    }

    var newChildren = this._split(node.props.children, splitDirections);

    return cloneWithChildren(node, newChildren, isRoot);
  };

  TruncateMarkup.prototype._splitString = function _splitString(string) {
    var splitDirections = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

    if (!splitDirections.length) {
      return string;
    }

    if (splitDirections.length && string.length === 1) {
      // we are trying to split further but we have nowhere to go now
      // that means we've already found the max subtree that fits the container
      this._endFound = true;

      return string;
    }

    var splitDirection = splitDirections[0],
        restSplitDirections = splitDirections.slice(1);

    var pivotIndex = Math.ceil(string.length / 2);

    if (splitDirection === SPLIT.LEFT) {
      var subString = string.substring(0, pivotIndex);

      return this._splitString(subString, restSplitDirections);
    }
    var beforeString = string.substring(0, pivotIndex);
    var afterString = string.substring(pivotIndex);

    return beforeString + this._splitString(afterString, restSplitDirections);
  };

  TruncateMarkup.prototype._splitArray = function _splitArray(array) {
    var splitDirections = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

    if (!splitDirections.length) {
      return array;
    }

    if (array.length === 1) {
      var item = array[0];


      if (typeof item === 'string') {
        return [this._splitString(item, splitDirections)];
      }
      var children = item.props.children;


      var newChildren = this._split(children, splitDirections);

      return [cloneWithChildren(item, newChildren)];
    }

    var splitDirection = splitDirections[0],
        restSplitDirections = splitDirections.slice(1);

    var pivotIndex = Math.ceil(array.length / 2);

    if (splitDirection === SPLIT.LEFT) {
      var subArray = array.slice(0, pivotIndex);

      return this._splitArray(subArray, restSplitDirections);
    }
    var beforeArray = array.slice(0, pivotIndex);
    var afterArray = array.slice(pivotIndex);

    return beforeArray.concat(this._splitArray(afterArray, restSplitDirections));
  };

  TruncateMarkup.prototype._fits = function _fits() {
    var maxLines = this.props.lines;

    var _el$getBoundingClient = this.el.getBoundingClientRect(),
        height = _el$getBoundingClient.height;

    var computedLines = Math.round(height / parseFloat(this._lineHeight));

    if (process.env.NODE_ENV !== 'production' && computedLines <= 0) {
      /* eslint-disable no-console */
      console.warn('TruncateMarkup: number of currently rendered lines: ' + computedLines + ', not truncating...\nIt may be caused by target element not being visible at the time of computation.');
      /* eslint-enable */
    }

    return maxLines >= computedLines;
  };

  TruncateMarkup.prototype.render = function render() {
    return this.state.text;
  };

  return TruncateMarkup;
}(_react2.default.Component), _class.defaultProps = {
  lines: 1,
  ellipsis: '...',
  lineHeight: ''
}, _temp2);
exports.default = TruncateMarkup;
TruncateMarkup.propTypes = process.env.NODE_ENV !== "production" ? {
  children: _propTypes2.default.element.isRequired,
  lines: _propTypes2.default.number,
  ellipsis: _propTypes2.default.oneOfType([_propTypes2.default.element, _propTypes2.default.string, _propTypes2.default.func]),
  lineHeight: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.number])
} : {};
module.exports = exports['default'];