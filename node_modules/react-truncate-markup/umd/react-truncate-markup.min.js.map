{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///react-truncate-markup.min.js","webpack:///webpack/bootstrap c12e12a795dfb3faa06e","webpack:///./src/index.js","webpack:///external {\"root\":\"React\",\"commonjs2\":\"react\",\"commonjs\":\"react\",\"amd\":\"react\"}","webpack:///./node_modules/line-height/lib/line-height.js","webpack:///./node_modules/computed-style/dist/computedStyle.commonjs.js","webpack:///./node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js"],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_2__","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","__webpack_exports__","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","create","constructor","value","writable","setPrototypeOf","__proto__","TruncateMarkup","_class","_temp2","__WEBPACK_IMPORTED_MODULE_0_react__","__WEBPACK_IMPORTED_MODULE_0_react___default","__WEBPACK_IMPORTED_MODULE_1_line_height__","__WEBPACK_IMPORTED_MODULE_1_line_height___default","__WEBPACK_IMPORTED_MODULE_2_resize_observer_polyfill__","_typeof","Symbol","iterator","obj","_extends","assign","target","arguments","length","source","key","SPLIT","LEFT","RIGHT","cloneWithChildren","node","children","isRootEl","props","style","display","_React$Component","_temp","_this","_ret","_len","args","Array","_key","apply","concat","state","text","_childrenElementWithRef","componentDidMount","_this2","_origText","_splitDirectionSeq","_shouldTruncate","_lineHeight","lineHeight","el","_truncate","initialRender","resizeObserver","setState","observe","componentWillReceiveProps","nextProps","_this3","componentDidUpdate","_endFound","_latestThatFits","clientWidth","_clientWidth","_truncateOriginalText","_fits","splice","push","_tryToFit","componentWillUnmount","disconnect","_this4","child","a","Children","only","cloneElement","ref","rootEl","splitDirections","newRootEl","_split","ellipsis","newChildren","newChildrenWithEllipsis","isArray","wordWrap","isRoot","undefined","_splitString","_splitArray","string","splitDirection","restSplitDirections","slice","pivotIndex","Math","ceil","subString","substring","beforeString","afterString","array","item","subArray","beforeArray","afterArray","maxLines","lines","_el$getBoundingClient","getBoundingClientRect","height","computedLines","round","parseFloat","render","Component","defaultProps","lnHeightStr","computedStyle","lnHeight","_lnHeightStyle","indexOf","nodeName","_node","document","createElement","innerHTML","toUpperCase","setAttribute","fontSizeStr","fontSize","padding","border","body","appendChild","offsetHeight","removeChild","prop","getComputedStyle","window","currentStyle","replace","word","letter","toFloat","getBordersSize","styles","reduce","size","position","getPaddings","positions","paddings","list","getSVGContentRect","bbox","getBBox","createRectInit","width","getHTMLElementContentRect","clientHeight","emptyRect","horizPad","left","right","vertPad","top","bottom","boxSizing","isDocumentElement","vertScrollbar","horizScrollbar","abs","documentElement","getContentRect","isBrowser","isSVGGraphicsElement","createReadOnlyRect","x","y","Constr","DOMRectReadOnly","rect","defineConfigurable","MapShim","getIndex","arr","result","some","entry","index","Map","anonymous","__entries__","prototypeAccessors","set","delete","entries","has","clear","forEach","callback","ctx","defineProperties","requestAnimationFrame$1","requestAnimationFrame","setTimeout","Date","now","trailingTimeout","throttle","delay","resolvePending","leadingCall","trailingCall","proxy","timeoutCallback","timeStamp","lastCallTime","transitionKeys","isIE11","navigator","test","userAgent","mutationObserverSupported","MutationObserver","ResizeObserverController","connected_","mutationEventsAdded_","mutationsObserver_","observers_","onTransitionEnd_","bind","refresh","addObserver","observer","connect_","removeObserver","observers","disconnect_","updateObservers_","activeObservers","filter","gatherActive","hasActive","broadcastActive","addEventListener","attributes","childList","characterData","subtree","removeEventListener","propertyName","getInstance","instance_","keys","SVGGraphicsElement","SVGElement","ResizeObservation","broadcastWidth","broadcastHeight","contentRect_","isActive","broadcastRect","ResizeObserverEntry","rectInit","contentRect","ResizeObserverSPI","controller","callbackCtx","activeObservations_","observations_","callback_","controller_","callbackCtx_","Element","observations","unobserve","clearActive","this$1","observation","map","WeakMap","ResizeObserver$1","method","ResizeObserver"],"mappings":"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","file":"react-truncate-markup.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"react\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"react\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ReactTruncateMarkup\"] = factory(require(\"react\"));\n\telse\n\t\troot[\"ReactTruncateMarkup\"] = factory(root[\"React\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_2__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"react\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"react\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ReactTruncateMarkup\"] = factory(require(\"react\"));\n\telse\n\t\troot[\"ReactTruncateMarkup\"] = factory(root[\"React\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_2__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(1);\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return TruncateMarkup; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_line_height__ = __webpack_require__(3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_line_height___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_line_height__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_resize_observer_polyfill__ = __webpack_require__(5);\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _class, _temp2;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\n\n\n\nvar SPLIT = {\n  LEFT: true,\n  RIGHT: false\n};\n\nvar cloneWithChildren = function cloneWithChildren(node, children, isRootEl) {\n  return _extends({}, node, {\n    props: _extends({}, node.props, {\n      style: _extends({}, node.props.style, !isRootEl ? {\n        display: (node.props.style || {}).display || 'inline'\n      } : {}),\n      children: children\n    })\n  });\n};\n\nvar TruncateMarkup = (_temp2 = _class = function (_React$Component) {\n  _inherits(TruncateMarkup, _React$Component);\n\n  function TruncateMarkup() {\n    var _temp, _this, _ret;\n\n    _classCallCheck(this, TruncateMarkup);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = {\n      text: _this._childrenElementWithRef(_this.props.children)\n    }, _temp), _possibleConstructorReturn(_this, _ret);\n  }\n\n  TruncateMarkup.prototype.componentDidMount = function componentDidMount() {\n    var _this2 = this;\n\n    this._origText = this.state.text;\n    this._splitDirectionSeq = [];\n    this._shouldTruncate = true;\n\n    // get the computed line-height of the parent element\n    // it'll be used for determining whether the text fits the container or not\n    this._lineHeight = this.props.lineHeight || __WEBPACK_IMPORTED_MODULE_1_line_height___default()(this.el);\n\n    this._truncate();\n\n    /* Wrapper element resize handing */\n    var initialRender = true;\n\n    this.resizeObserver = new __WEBPACK_IMPORTED_MODULE_2_resize_observer_polyfill__[\"a\" /* default */](function () {\n      if (initialRender) {\n        // ResizeObserer cb is called on initial render too so we are skipping here\n        initialRender = false;\n      } else {\n        // wrapper element has been resized, recalculating with the original text\n        _this2.setState({\n          text: _this2._origText\n        }, function () {\n          _this2._shouldTruncate = true;\n          _this2._truncate();\n        });\n      }\n    });\n\n    this.resizeObserver.observe(this.el);\n  };\n\n  TruncateMarkup.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {\n    var _this3 = this;\n\n    this.setState({\n      text: this._childrenElementWithRef(nextProps.children)\n    }, function () {\n      _this3._origText = _this3.state.text;\n      _this3._lineHeight = nextProps.lineHeight || __WEBPACK_IMPORTED_MODULE_1_line_height___default()(_this3.el);\n      _this3._shouldTruncate = true;\n      _this3._truncate();\n    });\n  };\n\n  TruncateMarkup.prototype.componentDidUpdate = function componentDidUpdate() {\n    if (this._shouldTruncate === false) {\n      return;\n    }\n\n    if (this._endFound) {\n      // we've found the end where we cannot split the text further\n      // that means we've already found the max subtree that fits the container\n      // so we are rendering that\n      if (this.state.text !== this._latestThatFits) {\n        /* eslint-disable react/no-did-update-set-state */\n        this.setState({\n          text: this._latestThatFits\n        });\n        /* eslint-enable */\n      } else if (this.el && this.el.clientWidth !== this._clientWidth) {\n        // edge case - scrollbar (dis?)appearing might mess up the container width\n        // causing strings that would normally fit on X lines to suddenly take up X+1 lines\n        // ugly fix - recalculate again\n        this._truncateOriginalText();\n      }\n\n      return;\n    }\n\n    if (this._splitDirectionSeq.length) {\n      if (this._fits()) {\n        this._latestThatFits = this.state.text;\n        this._clientWidth = this.el.clientWidth;\n        // we've found a subtree that fits the container\n        // but we need to check if we didn't cut too much of it off\n        // so we are changing the last splitting decision from splitting and going left\n        // to splitting and going right\n        this._splitDirectionSeq.splice(this._splitDirectionSeq.length - 1, 1, SPLIT.RIGHT, SPLIT.LEFT);\n      } else {\n        this._splitDirectionSeq.push(SPLIT.LEFT);\n      }\n\n      this._tryToFit(this._origText, this._splitDirectionSeq);\n    }\n  };\n\n  TruncateMarkup.prototype.componentWillUnmount = function componentWillUnmount() {\n    if (this.resizeObserver) {\n      this.resizeObserver.disconnect();\n    }\n\n    this._lineHeight = null;\n    this._origText = null;\n    this._latestThatFits = null;\n    this._splitDirectionSeq = [];\n  };\n\n  TruncateMarkup.prototype._truncate = function _truncate() {\n    if (this._fits()) {\n      // the whole text fits on the first try, no need to do anything else\n      this._shouldTruncate = false;\n\n      return;\n    }\n\n    this._latestThatFits = null;\n\n    this._truncateOriginalText();\n  };\n\n  TruncateMarkup.prototype._childrenElementWithRef = function _childrenElementWithRef(children) {\n    var _this4 = this;\n\n    var child = __WEBPACK_IMPORTED_MODULE_0_react___default.a.Children.only(children);\n\n    return __WEBPACK_IMPORTED_MODULE_0_react___default.a.cloneElement(child, { ref: function ref(el) {\n        return _this4.el = el;\n      } });\n  };\n\n  TruncateMarkup.prototype._truncateOriginalText = function _truncateOriginalText() {\n    this._endFound = false;\n    this._splitDirectionSeq = [SPLIT.LEFT];\n\n    this._tryToFit(this._origText, this._splitDirectionSeq);\n  };\n\n  /**\n   * Splits rootEl based on instructions and updates React's state with the returned element\n   * After React rerenders the new text, we'll check if the new text fits in componentDidUpdate\n   * @param  {ReactElement} rootEl - the original children element\n   * @param  {Array} splitDirections - list of SPLIT.RIGHT/LEFT instructions\n   */\n\n\n  TruncateMarkup.prototype._tryToFit = function _tryToFit(rootEl, splitDirections) {\n    if (!rootEl.props.children) {\n      // no markup in container\n      return;\n    }\n\n    var newRootEl = this._split(rootEl, splitDirections, /* isRootEl */true);\n\n    var ellipsis = typeof this.props.ellipsis === 'function' ? this.props.ellipsis(newRootEl) : _typeof(this.props.ellipsis) === 'object' ? __WEBPACK_IMPORTED_MODULE_0_react___default.a.cloneElement(this.props.ellipsis, { key: 'ellipsis' }) : this.props.ellipsis;\n\n    var newChildren = newRootEl.props.children;\n    var newChildrenWithEllipsis = Array.isArray(newChildren) ? [].concat(newChildren, [ellipsis]) : [newChildren, ellipsis];\n\n    this.setState({\n      text: _extends({}, newRootEl, {\n        props: _extends({}, newRootEl.props, {\n          style: _extends({\n            wordWrap: 'break-word'\n          }, newRootEl.props.style),\n          children: newChildrenWithEllipsis\n        })\n      })\n    });\n  };\n\n  /**\n   * Splits JSX node based on its type\n   * @param  {null|string|Array|Object} node - JSX node\n   * @param  {Array} splitDirections - list of SPLIT.RIGHT/LEFT instructions\n   * @return {null|string|Array|Object} - split JSX node\n   */\n\n\n  TruncateMarkup.prototype._split = function _split(node, splitDirections) {\n    var isRoot = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n    if (!node) {\n      return node;\n    } else if (typeof node === 'string') {\n      return this._splitString(node, splitDirections);\n    } else if (Array.isArray(node)) {\n      return this._splitArray(node, splitDirections);\n    }\n\n    var newChildren = this._split(node.props.children, splitDirections);\n\n    return cloneWithChildren(node, newChildren, isRoot);\n  };\n\n  TruncateMarkup.prototype._splitString = function _splitString(string) {\n    var splitDirections = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n    if (!splitDirections.length) {\n      return string;\n    }\n\n    if (splitDirections.length && string.length === 1) {\n      // we are trying to split further but we have nowhere to go now\n      // that means we've already found the max subtree that fits the container\n      this._endFound = true;\n\n      return string;\n    }\n\n    var splitDirection = splitDirections[0],\n        restSplitDirections = splitDirections.slice(1);\n\n    var pivotIndex = Math.ceil(string.length / 2);\n\n    if (splitDirection === SPLIT.LEFT) {\n      var subString = string.substring(0, pivotIndex);\n\n      return this._splitString(subString, restSplitDirections);\n    }\n    var beforeString = string.substring(0, pivotIndex);\n    var afterString = string.substring(pivotIndex);\n\n    return beforeString + this._splitString(afterString, restSplitDirections);\n  };\n\n  TruncateMarkup.prototype._splitArray = function _splitArray(array) {\n    var splitDirections = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n    if (!splitDirections.length) {\n      return array;\n    }\n\n    if (array.length === 1) {\n      var item = array[0];\n\n\n      if (typeof item === 'string') {\n        return [this._splitString(item, splitDirections)];\n      }\n      var children = item.props.children;\n\n\n      var newChildren = this._split(children, splitDirections);\n\n      return [cloneWithChildren(item, newChildren)];\n    }\n\n    var splitDirection = splitDirections[0],\n        restSplitDirections = splitDirections.slice(1);\n\n    var pivotIndex = Math.ceil(array.length / 2);\n\n    if (splitDirection === SPLIT.LEFT) {\n      var subArray = array.slice(0, pivotIndex);\n\n      return this._splitArray(subArray, restSplitDirections);\n    }\n    var beforeArray = array.slice(0, pivotIndex);\n    var afterArray = array.slice(pivotIndex);\n\n    return beforeArray.concat(this._splitArray(afterArray, restSplitDirections));\n  };\n\n  TruncateMarkup.prototype._fits = function _fits() {\n    var maxLines = this.props.lines;\n\n    var _el$getBoundingClient = this.el.getBoundingClientRect(),\n        height = _el$getBoundingClient.height;\n\n    var computedLines = Math.round(height / parseFloat(this._lineHeight));\n\n    if (false) {\n      /* eslint-disable no-console */\n      console.warn('TruncateMarkup: number of currently rendered lines: ' + computedLines + ', not truncating...\\nIt may be caused by target element not being visible at the time of computation.');\n      /* eslint-enable */\n    }\n\n    return maxLines >= computedLines;\n  };\n\n  TruncateMarkup.prototype.render = function render() {\n    return this.state.text;\n  };\n\n  return TruncateMarkup;\n}(__WEBPACK_IMPORTED_MODULE_0_react___default.a.Component), _class.defaultProps = {\n  lines: 1,\n  ellipsis: '...',\n  lineHeight: ''\n}, _temp2);\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_2__;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// Load in dependencies\nvar computedStyle = __webpack_require__(4);\n\n/**\n * Calculate the `line-height` of a given node\n * @param {HTMLElement} node Element to calculate line height of. Must be in the DOM.\n * @returns {Number} `line-height` of the element in pixels\n */\nfunction lineHeight(node) {\n  // Grab the line-height via style\n  var lnHeightStr = computedStyle(node, 'line-height');\n  var lnHeight = parseFloat(lnHeightStr, 10);\n\n  // If the lineHeight did not contain a unit (i.e. it was numeric), convert it to ems (e.g. '2.3' === '2.3em')\n  if (lnHeightStr === lnHeight + '') {\n    // Save the old lineHeight style and update the em unit to the element\n    var _lnHeightStyle = node.style.lineHeight;\n    node.style.lineHeight = lnHeightStr + 'em';\n\n    // Calculate the em based height\n    lnHeightStr = computedStyle(node, 'line-height');\n    lnHeight = parseFloat(lnHeightStr, 10);\n\n    // Revert the lineHeight style\n    if (_lnHeightStyle) {\n      node.style.lineHeight = _lnHeightStyle;\n    } else {\n      delete node.style.lineHeight;\n    }\n  }\n\n  // If the lineHeight is in `pt`, convert it to pixels (4px for 3pt)\n  // DEV: `em` units are converted to `pt` in IE6\n  // Conversion ratio from https://developer.mozilla.org/en-US/docs/Web/CSS/length\n  if (lnHeightStr.indexOf('pt') !== -1) {\n    lnHeight *= 4;\n    lnHeight /= 3;\n  // Otherwise, if the lineHeight is in `mm`, convert it to pixels (96px for 25.4mm)\n  } else if (lnHeightStr.indexOf('mm') !== -1) {\n    lnHeight *= 96;\n    lnHeight /= 25.4;\n  // Otherwise, if the lineHeight is in `cm`, convert it to pixels (96px for 2.54cm)\n  } else if (lnHeightStr.indexOf('cm') !== -1) {\n    lnHeight *= 96;\n    lnHeight /= 2.54;\n  // Otherwise, if the lineHeight is in `in`, convert it to pixels (96px for 1in)\n  } else if (lnHeightStr.indexOf('in') !== -1) {\n    lnHeight *= 96;\n  // Otherwise, if the lineHeight is in `pc`, convert it to pixels (12pt for 1pc)\n  } else if (lnHeightStr.indexOf('pc') !== -1) {\n    lnHeight *= 16;\n  }\n\n  // Continue our computation\n  lnHeight = Math.round(lnHeight);\n\n  // If the line-height is \"normal\", calculate by font-size\n  if (lnHeightStr === 'normal') {\n    // Create a temporary node\n    var nodeName = node.nodeName;\n    var _node = document.createElement(nodeName);\n    _node.innerHTML = '&nbsp;';\n\n    // If we have a text area, reset it to only 1 row\n    // https://github.com/twolfson/line-height/issues/4\n    if (nodeName.toUpperCase() === 'TEXTAREA') {\n      _node.setAttribute('rows', '1');\n    }\n\n    // Set the font-size of the element\n    var fontSizeStr = computedStyle(node, 'font-size');\n    _node.style.fontSize = fontSizeStr;\n\n    // Remove default padding/border which can affect offset height\n    // https://github.com/twolfson/line-height/issues/4\n    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetHeight\n    _node.style.padding = '0px';\n    _node.style.border = '0px';\n\n    // Append it to the body\n    var body = document.body;\n    body.appendChild(_node);\n\n    // Assume the line height of the element is the height\n    var height = _node.offsetHeight;\n    lnHeight = height;\n\n    // Remove our child from the DOM\n    body.removeChild(_node);\n  }\n\n  // Return the calculated height\n  return lnHeight;\n}\n\n// Export lineHeight\nmodule.exports = lineHeight;\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports) {\n\n// This code has been refactored for 140 bytes\n// You can see the original here: https://github.com/twolfson/computedStyle/blob/04cd1da2e30fa45844f95f5cb1ac898e9b9ef050/lib/computedStyle.js\nvar computedStyle = function (el, prop, getComputedStyle) {\n  getComputedStyle = window.getComputedStyle;\n\n  // In one fell swoop\n  return (\n    // If we have getComputedStyle\n    getComputedStyle ?\n      // Query it\n      // TODO: From CSS-Query notes, we might need (node, null) for FF\n      getComputedStyle(el) :\n\n    // Otherwise, we are in IE and use currentStyle\n      el.currentStyle\n  )[\n    // Switch to camelCase for CSSOM\n    // DEV: Grabbed from jQuery\n    // https://github.com/jquery/jquery/blob/1.9-stable/src/css.js#L191-L194\n    // https://github.com/jquery/jquery/blob/1.9-stable/src/core.js#L593-L597\n    prop.replace(/-(\\w)/gi, function (word, letter) {\n      return letter.toUpperCase();\n    })\n  ];\n};\n\nmodule.exports = computedStyle;\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/**\r\n * A collection of shims that provide minimal functionality of the ES6 collections.\r\n *\r\n * These implementations are not meant to be used outside of the ResizeObserver\r\n * modules as they cover only a limited range of use cases.\r\n */\r\n/* eslint-disable require-jsdoc, valid-jsdoc */\r\nvar MapShim = (function () {\r\n    if (typeof Map != 'undefined') {\r\n        return Map;\r\n    }\r\n\r\n    /**\r\n     * Returns index in provided array that matches the specified key.\r\n     *\r\n     * @param {Array<Array>} arr\r\n     * @param {*} key\r\n     * @returns {number}\r\n     */\r\n    function getIndex(arr, key) {\r\n        var result = -1;\r\n\r\n        arr.some(function (entry, index) {\r\n            if (entry[0] === key) {\r\n                result = index;\r\n\r\n                return true;\r\n            }\r\n\r\n            return false;\r\n        });\r\n\r\n        return result;\r\n    }\r\n\r\n    return (function () {\r\n        function anonymous() {\r\n            this.__entries__ = [];\r\n        }\r\n\r\n        var prototypeAccessors = { size: {} };\r\n\r\n        /**\r\n         * @returns {boolean}\r\n         */\r\n        prototypeAccessors.size.get = function () {\r\n            return this.__entries__.length;\r\n        };\r\n\r\n        /**\r\n         * @param {*} key\r\n         * @returns {*}\r\n         */\r\n        anonymous.prototype.get = function (key) {\r\n            var index = getIndex(this.__entries__, key);\r\n            var entry = this.__entries__[index];\r\n\r\n            return entry && entry[1];\r\n        };\r\n\r\n        /**\r\n         * @param {*} key\r\n         * @param {*} value\r\n         * @returns {void}\r\n         */\r\n        anonymous.prototype.set = function (key, value) {\r\n            var index = getIndex(this.__entries__, key);\r\n\r\n            if (~index) {\r\n                this.__entries__[index][1] = value;\r\n            } else {\r\n                this.__entries__.push([key, value]);\r\n            }\r\n        };\r\n\r\n        /**\r\n         * @param {*} key\r\n         * @returns {void}\r\n         */\r\n        anonymous.prototype.delete = function (key) {\r\n            var entries = this.__entries__;\r\n            var index = getIndex(entries, key);\r\n\r\n            if (~index) {\r\n                entries.splice(index, 1);\r\n            }\r\n        };\r\n\r\n        /**\r\n         * @param {*} key\r\n         * @returns {void}\r\n         */\r\n        anonymous.prototype.has = function (key) {\r\n            return !!~getIndex(this.__entries__, key);\r\n        };\r\n\r\n        /**\r\n         * @returns {void}\r\n         */\r\n        anonymous.prototype.clear = function () {\r\n            this.__entries__.splice(0);\r\n        };\r\n\r\n        /**\r\n         * @param {Function} callback\r\n         * @param {*} [ctx=null]\r\n         * @returns {void}\r\n         */\r\n        anonymous.prototype.forEach = function (callback, ctx) {\r\n            if ( ctx === void 0 ) ctx = null;\r\n\r\n            for (var i = 0, list = this.__entries__; i < list.length; i += 1) {\r\n                var entry = list[i];\r\n\r\n                callback.call(ctx, entry[1], entry[0]);\r\n            }\r\n        };\r\n\r\n        Object.defineProperties( anonymous.prototype, prototypeAccessors );\r\n\r\n        return anonymous;\r\n    }());\r\n})();\r\n\r\n/**\r\n * Detects whether window and document objects are available in current environment.\r\n */\r\nvar isBrowser = typeof window != 'undefined' && typeof document != 'undefined' && window.document === document;\r\n\r\n/**\r\n * A shim for the requestAnimationFrame which falls back to the setTimeout if\r\n * first one is not supported.\r\n *\r\n * @returns {number} Requests' identifier.\r\n */\r\nvar requestAnimationFrame$1 = (function () {\r\n    if (typeof requestAnimationFrame === 'function') {\r\n        return requestAnimationFrame;\r\n    }\r\n\r\n    return function (callback) { return setTimeout(function () { return callback(Date.now()); }, 1000 / 60); };\r\n})();\r\n\r\n// Defines minimum timeout before adding a trailing call.\r\nvar trailingTimeout = 2;\r\n\r\n/**\r\n * Creates a wrapper function which ensures that provided callback will be\r\n * invoked only once during the specified delay period.\r\n *\r\n * @param {Function} callback - Function to be invoked after the delay period.\r\n * @param {number} delay - Delay after which to invoke callback.\r\n * @returns {Function}\r\n */\r\nvar throttle = function (callback, delay) {\r\n    var leadingCall = false,\r\n        trailingCall = false,\r\n        lastCallTime = 0;\r\n\r\n    /**\r\n     * Invokes the original callback function and schedules new invocation if\r\n     * the \"proxy\" was called during current request.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    function resolvePending() {\r\n        if (leadingCall) {\r\n            leadingCall = false;\r\n\r\n            callback();\r\n        }\r\n\r\n        if (trailingCall) {\r\n            proxy();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Callback invoked after the specified delay. It will further postpone\r\n     * invocation of the original function delegating it to the\r\n     * requestAnimationFrame.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    function timeoutCallback() {\r\n        requestAnimationFrame$1(resolvePending);\r\n    }\r\n\r\n    /**\r\n     * Schedules invocation of the original function.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    function proxy() {\r\n        var timeStamp = Date.now();\r\n\r\n        if (leadingCall) {\r\n            // Reject immediately following calls.\r\n            if (timeStamp - lastCallTime < trailingTimeout) {\r\n                return;\r\n            }\r\n\r\n            // Schedule new call to be in invoked when the pending one is resolved.\r\n            // This is important for \"transitions\" which never actually start\r\n            // immediately so there is a chance that we might miss one if change\r\n            // happens amids the pending invocation.\r\n            trailingCall = true;\r\n        } else {\r\n            leadingCall = true;\r\n            trailingCall = false;\r\n\r\n            setTimeout(timeoutCallback, delay);\r\n        }\r\n\r\n        lastCallTime = timeStamp;\r\n    }\r\n\r\n    return proxy;\r\n};\r\n\r\n// Minimum delay before invoking the update of observers.\r\nvar REFRESH_DELAY = 20;\r\n\r\n// A list of substrings of CSS properties used to find transition events that\r\n// might affect dimensions of observed elements.\r\nvar transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight'];\r\n\r\n// Detect whether running in IE 11 (facepalm).\r\nvar isIE11 = typeof navigator != 'undefined' && /Trident\\/.*rv:11/.test(navigator.userAgent);\r\n\r\n// MutationObserver should not be used if running in Internet Explorer 11 as it's\r\n// implementation is unreliable. Example: https://jsfiddle.net/x2r3jpuz/2/\r\n//\r\n// It's a real bummer that there is no other way to check for this issue but to\r\n// use the UA information.\r\nvar mutationObserverSupported = typeof MutationObserver != 'undefined' && !isIE11;\r\n\r\n/**\r\n * Singleton controller class which handles updates of ResizeObserver instances.\r\n */\r\nvar ResizeObserverController = function() {\r\n    /**\r\n     * Indicates whether DOM listeners have been added.\r\n     *\r\n     * @private {boolean}\r\n     */\r\n    this.connected_ = false;\r\n\r\n    /**\r\n     * Tells that controller has subscribed for Mutation Events.\r\n     *\r\n     * @private {boolean}\r\n     */\r\n    this.mutationEventsAdded_ = false;\r\n\r\n    /**\r\n     * Keeps reference to the instance of MutationObserver.\r\n     *\r\n     * @private {MutationObserver}\r\n     */\r\n    this.mutationsObserver_ = null;\r\n\r\n    /**\r\n     * A list of connected observers.\r\n     *\r\n     * @private {Array<ResizeObserverSPI>}\r\n     */\r\n    this.observers_ = [];\r\n\r\n    this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);\r\n    this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);\r\n};\r\n\r\n/**\r\n * Adds observer to observers list.\r\n *\r\n * @param {ResizeObserverSPI} observer - Observer to be added.\r\n * @returns {void}\r\n */\r\nResizeObserverController.prototype.addObserver = function (observer) {\r\n    if (!~this.observers_.indexOf(observer)) {\r\n        this.observers_.push(observer);\r\n    }\r\n\r\n    // Add listeners if they haven't been added yet.\r\n    if (!this.connected_) {\r\n        this.connect_();\r\n    }\r\n};\r\n\r\n/**\r\n * Removes observer from observers list.\r\n *\r\n * @param {ResizeObserverSPI} observer - Observer to be removed.\r\n * @returns {void}\r\n */\r\nResizeObserverController.prototype.removeObserver = function (observer) {\r\n    var observers = this.observers_;\r\n    var index = observers.indexOf(observer);\r\n\r\n    // Remove observer if it's present in registry.\r\n    if (~index) {\r\n        observers.splice(index, 1);\r\n    }\r\n\r\n    // Remove listeners if controller has no connected observers.\r\n    if (!observers.length && this.connected_) {\r\n        this.disconnect_();\r\n    }\r\n};\r\n\r\n/**\r\n * Invokes the update of observers. It will continue running updates insofar\r\n * it detects changes.\r\n *\r\n * @returns {void}\r\n */\r\nResizeObserverController.prototype.refresh = function () {\r\n    var changesDetected = this.updateObservers_();\r\n\r\n    // Continue running updates if changes have been detected as there might\r\n    // be future ones caused by CSS transitions.\r\n    if (changesDetected) {\r\n        this.refresh();\r\n    }\r\n};\r\n\r\n/**\r\n * Updates every observer from observers list and notifies them of queued\r\n * entries.\r\n *\r\n * @private\r\n * @returns {boolean} Returns \"true\" if any observer has detected changes in\r\n *  dimensions of it's elements.\r\n */\r\nResizeObserverController.prototype.updateObservers_ = function () {\r\n    // Collect observers that have active observations.\r\n    var activeObservers = this.observers_.filter(function (observer) {\r\n        return observer.gatherActive(), observer.hasActive();\r\n    });\r\n\r\n    // Deliver notifications in a separate cycle in order to avoid any\r\n    // collisions between observers, e.g. when multiple instances of\r\n    // ResizeObserver are tracking the same element and the callback of one\r\n    // of them changes content dimensions of the observed target. Sometimes\r\n    // this may result in notifications being blocked for the rest of observers.\r\n    activeObservers.forEach(function (observer) { return observer.broadcastActive(); });\r\n\r\n    return activeObservers.length > 0;\r\n};\r\n\r\n/**\r\n * Initializes DOM listeners.\r\n *\r\n * @private\r\n * @returns {void}\r\n */\r\nResizeObserverController.prototype.connect_ = function () {\r\n    // Do nothing if running in a non-browser environment or if listeners\r\n    // have been already added.\r\n    if (!isBrowser || this.connected_) {\r\n        return;\r\n    }\r\n\r\n    // Subscription to the \"Transitionend\" event is used as a workaround for\r\n    // delayed transitions. This way it's possible to capture at least the\r\n    // final state of an element.\r\n    document.addEventListener('transitionend', this.onTransitionEnd_);\r\n\r\n    window.addEventListener('resize', this.refresh);\r\n\r\n    if (mutationObserverSupported) {\r\n        this.mutationsObserver_ = new MutationObserver(this.refresh);\r\n\r\n        this.mutationsObserver_.observe(document, {\r\n            attributes: true,\r\n            childList: true,\r\n            characterData: true,\r\n            subtree: true\r\n        });\r\n    } else {\r\n        document.addEventListener('DOMSubtreeModified', this.refresh);\r\n\r\n        this.mutationEventsAdded_ = true;\r\n    }\r\n\r\n    this.connected_ = true;\r\n};\r\n\r\n/**\r\n * Removes DOM listeners.\r\n *\r\n * @private\r\n * @returns {void}\r\n */\r\nResizeObserverController.prototype.disconnect_ = function () {\r\n    // Do nothing if running in a non-browser environment or if listeners\r\n    // have been already removed.\r\n    if (!isBrowser || !this.connected_) {\r\n        return;\r\n    }\r\n\r\n    document.removeEventListener('transitionend', this.onTransitionEnd_);\r\n    window.removeEventListener('resize', this.refresh);\r\n\r\n    if (this.mutationsObserver_) {\r\n        this.mutationsObserver_.disconnect();\r\n    }\r\n\r\n    if (this.mutationEventsAdded_) {\r\n        document.removeEventListener('DOMSubtreeModified', this.refresh);\r\n    }\r\n\r\n    this.mutationsObserver_ = null;\r\n    this.mutationEventsAdded_ = false;\r\n    this.connected_ = false;\r\n};\r\n\r\n/**\r\n * \"Transitionend\" event handler.\r\n *\r\n * @private\r\n * @param {TransitionEvent} event\r\n * @returns {void}\r\n */\r\nResizeObserverController.prototype.onTransitionEnd_ = function (ref) {\r\n        var propertyName = ref.propertyName;\r\n\r\n    // Detect whether transition may affect dimensions of an element.\r\n    var isReflowProperty = transitionKeys.some(function (key) {\r\n        return !!~propertyName.indexOf(key);\r\n    });\r\n\r\n    if (isReflowProperty) {\r\n        this.refresh();\r\n    }\r\n};\r\n\r\n/**\r\n * Returns instance of the ResizeObserverController.\r\n *\r\n * @returns {ResizeObserverController}\r\n */\r\nResizeObserverController.getInstance = function () {\r\n    if (!this.instance_) {\r\n        this.instance_ = new ResizeObserverController();\r\n    }\r\n\r\n    return this.instance_;\r\n};\r\n\r\n/**\r\n * Holds reference to the controller's instance.\r\n *\r\n * @private {ResizeObserverController}\r\n */\r\nResizeObserverController.instance_ = null;\r\n\r\n/**\r\n * Defines non-writable/enumerable properties of the provided target object.\r\n *\r\n * @param {Object} target - Object for which to define properties.\r\n * @param {Object} props - Properties to be defined.\r\n * @returns {Object} Target object.\r\n */\r\nvar defineConfigurable = (function (target, props) {\r\n    for (var i = 0, list = Object.keys(props); i < list.length; i += 1) {\r\n        var key = list[i];\r\n\r\n        Object.defineProperty(target, key, {\r\n            value: props[key],\r\n            enumerable: false,\r\n            writable: false,\r\n            configurable: true\r\n        });\r\n    }\r\n\r\n    return target;\r\n});\r\n\r\n// Placeholder of an empty content rectangle.\r\nvar emptyRect = createRectInit(0, 0, 0, 0);\r\n\r\n/**\r\n * Converts provided string to a number.\r\n *\r\n * @param {number|string} value\r\n * @returns {number}\r\n */\r\nfunction toFloat(value) {\r\n    return parseFloat(value) || 0;\r\n}\r\n\r\n/**\r\n * Extracts borders size from provided styles.\r\n *\r\n * @param {CSSStyleDeclaration} styles\r\n * @param {...string} positions - Borders positions (top, right, ...)\r\n * @returns {number}\r\n */\r\nfunction getBordersSize(styles) {\r\n    var positions = Array.prototype.slice.call(arguments, 1);\r\n\r\n    return positions.reduce(function (size, position) {\r\n        var value = styles['border-' + position + '-width'];\r\n\r\n        return size + toFloat(value);\r\n    }, 0);\r\n}\r\n\r\n/**\r\n * Extracts paddings sizes from provided styles.\r\n *\r\n * @param {CSSStyleDeclaration} styles\r\n * @returns {Object} Paddings box.\r\n */\r\nfunction getPaddings(styles) {\r\n    var positions = ['top', 'right', 'bottom', 'left'];\r\n    var paddings = {};\r\n\r\n    for (var i = 0, list = positions; i < list.length; i += 1) {\r\n        var position = list[i];\r\n\r\n        var value = styles['padding-' + position];\r\n\r\n        paddings[position] = toFloat(value);\r\n    }\r\n\r\n    return paddings;\r\n}\r\n\r\n/**\r\n * Calculates content rectangle of provided SVG element.\r\n *\r\n * @param {SVGGraphicsElement} target - Element content rectangle of which needs\r\n *      to be calculated.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction getSVGContentRect(target) {\r\n    var bbox = target.getBBox();\r\n\r\n    return createRectInit(0, 0, bbox.width, bbox.height);\r\n}\r\n\r\n/**\r\n * Calculates content rectangle of provided HTMLElement.\r\n *\r\n * @param {HTMLElement} target - Element for which to calculate the content rectangle.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction getHTMLElementContentRect(target) {\r\n    // Client width & height properties can't be\r\n    // used exclusively as they provide rounded values.\r\n    var clientWidth = target.clientWidth;\r\n    var clientHeight = target.clientHeight;\r\n\r\n    // By this condition we can catch all non-replaced inline, hidden and\r\n    // detached elements. Though elements with width & height properties less\r\n    // than 0.5 will be discarded as well.\r\n    //\r\n    // Without it we would need to implement separate methods for each of\r\n    // those cases and it's not possible to perform a precise and performance\r\n    // effective test for hidden elements. E.g. even jQuery's ':visible' filter\r\n    // gives wrong results for elements with width & height less than 0.5.\r\n    if (!clientWidth && !clientHeight) {\r\n        return emptyRect;\r\n    }\r\n\r\n    var styles = getComputedStyle(target);\r\n    var paddings = getPaddings(styles);\r\n    var horizPad = paddings.left + paddings.right;\r\n    var vertPad = paddings.top + paddings.bottom;\r\n\r\n    // Computed styles of width & height are being used because they are the\r\n    // only dimensions available to JS that contain non-rounded values. It could\r\n    // be possible to utilize the getBoundingClientRect if only it's data wasn't\r\n    // affected by CSS transformations let alone paddings, borders and scroll bars.\r\n    var width = toFloat(styles.width),\r\n        height = toFloat(styles.height);\r\n\r\n    // Width & height include paddings and borders when the 'border-box' box\r\n    // model is applied (except for IE).\r\n    if (styles.boxSizing === 'border-box') {\r\n        // Following conditions are required to handle Internet Explorer which\r\n        // doesn't include paddings and borders to computed CSS dimensions.\r\n        //\r\n        // We can say that if CSS dimensions + paddings are equal to the \"client\"\r\n        // properties then it's either IE, and thus we don't need to subtract\r\n        // anything, or an element merely doesn't have paddings/borders styles.\r\n        if (Math.round(width + horizPad) !== clientWidth) {\r\n            width -= getBordersSize(styles, 'left', 'right') + horizPad;\r\n        }\r\n\r\n        if (Math.round(height + vertPad) !== clientHeight) {\r\n            height -= getBordersSize(styles, 'top', 'bottom') + vertPad;\r\n        }\r\n    }\r\n\r\n    // Following steps can't be applied to the document's root element as its\r\n    // client[Width/Height] properties represent viewport area of the window.\r\n    // Besides, it's as well not necessary as the <html> itself neither has\r\n    // rendered scroll bars nor it can be clipped.\r\n    if (!isDocumentElement(target)) {\r\n        // In some browsers (only in Firefox, actually) CSS width & height\r\n        // include scroll bars size which can be removed at this step as scroll\r\n        // bars are the only difference between rounded dimensions + paddings\r\n        // and \"client\" properties, though that is not always true in Chrome.\r\n        var vertScrollbar = Math.round(width + horizPad) - clientWidth;\r\n        var horizScrollbar = Math.round(height + vertPad) - clientHeight;\r\n\r\n        // Chrome has a rather weird rounding of \"client\" properties.\r\n        // E.g. for an element with content width of 314.2px it sometimes gives\r\n        // the client width of 315px and for the width of 314.7px it may give\r\n        // 314px. And it doesn't happen all the time. So just ignore this delta\r\n        // as a non-relevant.\r\n        if (Math.abs(vertScrollbar) !== 1) {\r\n            width -= vertScrollbar;\r\n        }\r\n\r\n        if (Math.abs(horizScrollbar) !== 1) {\r\n            height -= horizScrollbar;\r\n        }\r\n    }\r\n\r\n    return createRectInit(paddings.left, paddings.top, width, height);\r\n}\r\n\r\n/**\r\n * Checks whether provided element is an instance of the SVGGraphicsElement.\r\n *\r\n * @param {Element} target - Element to be checked.\r\n * @returns {boolean}\r\n */\r\nvar isSVGGraphicsElement = (function () {\r\n    // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement\r\n    // interface.\r\n    if (typeof SVGGraphicsElement != 'undefined') {\r\n        return function (target) { return target instanceof SVGGraphicsElement; };\r\n    }\r\n\r\n    // If it's so, then check that element is at least an instance of the\r\n    // SVGElement and that it has the \"getBBox\" method.\r\n    // eslint-disable-next-line no-extra-parens\r\n    return function (target) { return target instanceof SVGElement && typeof target.getBBox === 'function'; };\r\n})();\r\n\r\n/**\r\n * Checks whether provided element is a document element (<html>).\r\n *\r\n * @param {Element} target - Element to be checked.\r\n * @returns {boolean}\r\n */\r\nfunction isDocumentElement(target) {\r\n    return target === document.documentElement;\r\n}\r\n\r\n/**\r\n * Calculates an appropriate content rectangle for provided html or svg element.\r\n *\r\n * @param {Element} target - Element content rectangle of which needs to be calculated.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction getContentRect(target) {\r\n    if (!isBrowser) {\r\n        return emptyRect;\r\n    }\r\n\r\n    if (isSVGGraphicsElement(target)) {\r\n        return getSVGContentRect(target);\r\n    }\r\n\r\n    return getHTMLElementContentRect(target);\r\n}\r\n\r\n/**\r\n * Creates rectangle with an interface of the DOMRectReadOnly.\r\n * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly\r\n *\r\n * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.\r\n * @returns {DOMRectReadOnly}\r\n */\r\nfunction createReadOnlyRect(ref) {\r\n    var x = ref.x;\r\n    var y = ref.y;\r\n    var width = ref.width;\r\n    var height = ref.height;\r\n\r\n    // If DOMRectReadOnly is available use it as a prototype for the rectangle.\r\n    var Constr = typeof DOMRectReadOnly != 'undefined' ? DOMRectReadOnly : Object;\r\n    var rect = Object.create(Constr.prototype);\r\n\r\n    // Rectangle's properties are not writable and non-enumerable.\r\n    defineConfigurable(rect, {\r\n        x: x, y: y, width: width, height: height,\r\n        top: y,\r\n        right: x + width,\r\n        bottom: height + y,\r\n        left: x\r\n    });\r\n\r\n    return rect;\r\n}\r\n\r\n/**\r\n * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.\r\n * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit\r\n *\r\n * @param {number} x - X coordinate.\r\n * @param {number} y - Y coordinate.\r\n * @param {number} width - Rectangle's width.\r\n * @param {number} height - Rectangle's height.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction createRectInit(x, y, width, height) {\r\n    return { x: x, y: y, width: width, height: height };\r\n}\r\n\r\n/**\r\n * Class that is responsible for computations of the content rectangle of\r\n * provided DOM element and for keeping track of it's changes.\r\n */\r\nvar ResizeObservation = function(target) {\r\n    /**\r\n     * Broadcasted width of content rectangle.\r\n     *\r\n     * @type {number}\r\n     */\r\n    this.broadcastWidth = 0;\r\n\r\n    /**\r\n     * Broadcasted height of content rectangle.\r\n     *\r\n     * @type {number}\r\n     */\r\n    this.broadcastHeight = 0;\r\n\r\n    /**\r\n     * Reference to the last observed content rectangle.\r\n     *\r\n     * @private {DOMRectInit}\r\n     */\r\n    this.contentRect_ = createRectInit(0, 0, 0, 0);\r\n\r\n    /**\r\n     * Reference to the observed element.\r\n     *\r\n     * @type {Element}\r\n     */\r\n    this.target = target;\r\n};\r\n\r\n/**\r\n * Updates content rectangle and tells whether it's width or height properties\r\n * have changed since the last broadcast.\r\n *\r\n * @returns {boolean}\r\n */\r\nResizeObservation.prototype.isActive = function () {\r\n    var rect = getContentRect(this.target);\r\n\r\n    this.contentRect_ = rect;\r\n\r\n    return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;\r\n};\r\n\r\n/**\r\n * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data\r\n * from the corresponding properties of the last observed content rectangle.\r\n *\r\n * @returns {DOMRectInit} Last observed content rectangle.\r\n */\r\nResizeObservation.prototype.broadcastRect = function () {\r\n    var rect = this.contentRect_;\r\n\r\n    this.broadcastWidth = rect.width;\r\n    this.broadcastHeight = rect.height;\r\n\r\n    return rect;\r\n};\r\n\r\nvar ResizeObserverEntry = function(target, rectInit) {\r\n    var contentRect = createReadOnlyRect(rectInit);\r\n\r\n    // According to the specification following properties are not writable\r\n    // and are also not enumerable in the native implementation.\r\n    //\r\n    // Property accessors are not being used as they'd require to define a\r\n    // private WeakMap storage which may cause memory leaks in browsers that\r\n    // don't support this type of collections.\r\n    defineConfigurable(this, { target: target, contentRect: contentRect });\r\n};\r\n\r\nvar ResizeObserverSPI = function(callback, controller, callbackCtx) {\r\n    if (typeof callback !== 'function') {\r\n        throw new TypeError('The callback provided as parameter 1 is not a function.');\r\n    }\r\n\r\n    /**\r\n     * Collection of resize observations that have detected changes in dimensions\r\n     * of elements.\r\n     *\r\n     * @private {Array<ResizeObservation>}\r\n     */\r\n    this.activeObservations_ = [];\r\n\r\n    /**\r\n     * Registry of the ResizeObservation instances.\r\n     *\r\n     * @private {Map<Element, ResizeObservation>}\r\n     */\r\n    this.observations_ = new MapShim();\r\n\r\n    /**\r\n     * Reference to the callback function.\r\n     *\r\n     * @private {ResizeObserverCallback}\r\n     */\r\n    this.callback_ = callback;\r\n\r\n    /**\r\n     * Reference to the associated ResizeObserverController.\r\n     *\r\n     * @private {ResizeObserverController}\r\n     */\r\n    this.controller_ = controller;\r\n\r\n    /**\r\n     * Public ResizeObserver instance which will be passed to the callback\r\n     * function and used as a value of it's \"this\" binding.\r\n     *\r\n     * @private {ResizeObserver}\r\n     */\r\n    this.callbackCtx_ = callbackCtx;\r\n};\r\n\r\n/**\r\n * Starts observing provided element.\r\n *\r\n * @param {Element} target - Element to be observed.\r\n * @returns {void}\r\n */\r\nResizeObserverSPI.prototype.observe = function (target) {\r\n    if (!arguments.length) {\r\n        throw new TypeError('1 argument required, but only 0 present.');\r\n    }\r\n\r\n    // Do nothing if current environment doesn't have the Element interface.\r\n    if (typeof Element === 'undefined' || !(Element instanceof Object)) {\r\n        return;\r\n    }\r\n\r\n    if (!(target instanceof Element)) {\r\n        throw new TypeError('parameter 1 is not of type \"Element\".');\r\n    }\r\n\r\n    var observations = this.observations_;\r\n\r\n    // Do nothing if element is already being observed.\r\n    if (observations.has(target)) {\r\n        return;\r\n    }\r\n\r\n    observations.set(target, new ResizeObservation(target));\r\n\r\n    this.controller_.addObserver(this);\r\n\r\n    // Force the update of observations.\r\n    this.controller_.refresh();\r\n};\r\n\r\n/**\r\n * Stops observing provided element.\r\n *\r\n * @param {Element} target - Element to stop observing.\r\n * @returns {void}\r\n */\r\nResizeObserverSPI.prototype.unobserve = function (target) {\r\n    if (!arguments.length) {\r\n        throw new TypeError('1 argument required, but only 0 present.');\r\n    }\r\n\r\n    // Do nothing if current environment doesn't have the Element interface.\r\n    if (typeof Element === 'undefined' || !(Element instanceof Object)) {\r\n        return;\r\n    }\r\n\r\n    if (!(target instanceof Element)) {\r\n        throw new TypeError('parameter 1 is not of type \"Element\".');\r\n    }\r\n\r\n    var observations = this.observations_;\r\n\r\n    // Do nothing if element is not being observed.\r\n    if (!observations.has(target)) {\r\n        return;\r\n    }\r\n\r\n    observations.delete(target);\r\n\r\n    if (!observations.size) {\r\n        this.controller_.removeObserver(this);\r\n    }\r\n};\r\n\r\n/**\r\n * Stops observing all elements.\r\n *\r\n * @returns {void}\r\n */\r\nResizeObserverSPI.prototype.disconnect = function () {\r\n    this.clearActive();\r\n    this.observations_.clear();\r\n    this.controller_.removeObserver(this);\r\n};\r\n\r\n/**\r\n * Collects observation instances the associated element of which has changed\r\n * it's content rectangle.\r\n *\r\n * @returns {void}\r\n */\r\nResizeObserverSPI.prototype.gatherActive = function () {\r\n        var this$1 = this;\r\n\r\n    this.clearActive();\r\n\r\n    this.observations_.forEach(function (observation) {\r\n        if (observation.isActive()) {\r\n            this$1.activeObservations_.push(observation);\r\n        }\r\n    });\r\n};\r\n\r\n/**\r\n * Invokes initial callback function with a list of ResizeObserverEntry\r\n * instances collected from active resize observations.\r\n *\r\n * @returns {void}\r\n */\r\nResizeObserverSPI.prototype.broadcastActive = function () {\r\n    // Do nothing if observer doesn't have active observations.\r\n    if (!this.hasActive()) {\r\n        return;\r\n    }\r\n\r\n    var ctx = this.callbackCtx_;\r\n\r\n    // Create ResizeObserverEntry instance for every active observation.\r\n    var entries = this.activeObservations_.map(function (observation) {\r\n        return new ResizeObserverEntry(observation.target, observation.broadcastRect());\r\n    });\r\n\r\n    this.callback_.call(ctx, entries, ctx);\r\n    this.clearActive();\r\n};\r\n\r\n/**\r\n * Clears the collection of active observations.\r\n *\r\n * @returns {void}\r\n */\r\nResizeObserverSPI.prototype.clearActive = function () {\r\n    this.activeObservations_.splice(0);\r\n};\r\n\r\n/**\r\n * Tells whether observer has active observations.\r\n *\r\n * @returns {boolean}\r\n */\r\nResizeObserverSPI.prototype.hasActive = function () {\r\n    return this.activeObservations_.length > 0;\r\n};\r\n\r\n// Registry of internal observers. If WeakMap is not available use current shim\r\n// for the Map collection as it has all required methods and because WeakMap\r\n// can't be fully polyfilled anyway.\r\nvar observers = typeof WeakMap != 'undefined' ? new WeakMap() : new MapShim();\r\n\r\n/**\r\n * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation\r\n * exposing only those methods and properties that are defined in the spec.\r\n */\r\nvar ResizeObserver$1 = function(callback) {\r\n    if (!(this instanceof ResizeObserver$1)) {\r\n        throw new TypeError('Cannot call a class as a function');\r\n    }\r\n\r\n    if (!arguments.length) {\r\n        throw new TypeError('1 argument required, but only 0 present.');\r\n    }\r\n\r\n    var controller = ResizeObserverController.getInstance();\r\n    var observer = new ResizeObserverSPI(callback, controller, this);\r\n\r\n    observers.set(this, observer);\r\n};\r\n\r\n// Expose public methods of ResizeObserver.\r\n['observe', 'unobserve', 'disconnect'].forEach(function (method) {\r\n    ResizeObserver$1.prototype[method] = function () {\r\n        return (ref = observers.get(this))[method].apply(ref, arguments);\r\n        var ref;\r\n    };\r\n});\r\n\r\nvar index = (function () {\r\n    // Export existing implementation if available.\r\n    if (typeof ResizeObserver != 'undefined') {\r\n        // eslint-disable-next-line no-undef\r\n        return ResizeObserver;\r\n    }\r\n\r\n    return ResizeObserver$1;\r\n})();\r\n\r\n/* harmony default export */ __webpack_exports__[\"a\"] = (index);\r\n\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// react-truncate-markup.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap c12e12a795dfb3faa06e","import React from 'react';\nimport PropTypes from 'prop-types';\nimport getLineHeight from 'line-height';\nimport ResizeObserver from 'resize-observer-polyfill';\n\nconst SPLIT = {\n  LEFT: true,\n  RIGHT: false,\n};\n\nconst cloneWithChildren = (node, children, isRootEl) => ({\n  ...node,\n  props: {\n    ...node.props,\n    style: {\n      ...node.props.style,\n      ...(!isRootEl\n        ? {\n            display: (node.props.style || {}).display || 'inline',\n          }\n        : {}),\n    },\n    children,\n  },\n});\n\nexport default class TruncateMarkup extends React.Component {\n  static propTypes = {\n    children: PropTypes.element.isRequired,\n    lines: PropTypes.number,\n    ellipsis: PropTypes.oneOfType([\n      PropTypes.element,\n      PropTypes.string,\n      PropTypes.func,\n    ]),\n    lineHeight: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n  };\n\n  static defaultProps = {\n    lines: 1,\n    ellipsis: '...',\n    lineHeight: '',\n  };\n\n  state = {\n    text: this._childrenElementWithRef(this.props.children),\n  };\n\n  componentDidMount() {\n    this._origText = this.state.text;\n    this._splitDirectionSeq = [];\n    this._shouldTruncate = true;\n\n    // get the computed line-height of the parent element\n    // it'll be used for determining whether the text fits the container or not\n    this._lineHeight = this.props.lineHeight || getLineHeight(this.el);\n\n    this._truncate();\n\n    /* Wrapper element resize handing */\n    let initialRender = true;\n\n    this.resizeObserver = new ResizeObserver(() => {\n      if (initialRender) {\n        // ResizeObserer cb is called on initial render too so we are skipping here\n        initialRender = false;\n      } else {\n        // wrapper element has been resized, recalculating with the original text\n        this.setState(\n          {\n            text: this._origText,\n          },\n          () => {\n            this._shouldTruncate = true;\n            this._truncate();\n          },\n        );\n      }\n    });\n\n    this.resizeObserver.observe(this.el);\n  }\n\n  componentWillReceiveProps(nextProps) {\n    this.setState(\n      {\n        text: this._childrenElementWithRef(nextProps.children),\n      },\n      () => {\n        this._origText = this.state.text;\n        this._lineHeight = nextProps.lineHeight || getLineHeight(this.el);\n        this._shouldTruncate = true;\n        this._truncate();\n      },\n    );\n  }\n\n  componentDidUpdate() {\n    if (this._shouldTruncate === false) {\n      return;\n    }\n\n    if (this._endFound) {\n      // we've found the end where we cannot split the text further\n      // that means we've already found the max subtree that fits the container\n      // so we are rendering that\n      if (this.state.text !== this._latestThatFits) {\n        /* eslint-disable react/no-did-update-set-state */\n        this.setState({\n          text: this._latestThatFits,\n        });\n        /* eslint-enable */\n      } else if (this.el && this.el.clientWidth !== this._clientWidth) {\n        // edge case - scrollbar (dis?)appearing might mess up the container width\n        // causing strings that would normally fit on X lines to suddenly take up X+1 lines\n        // ugly fix - recalculate again\n        this._truncateOriginalText();\n      }\n\n      return;\n    }\n\n    if (this._splitDirectionSeq.length) {\n      if (this._fits()) {\n        this._latestThatFits = this.state.text;\n        this._clientWidth = this.el.clientWidth;\n        // we've found a subtree that fits the container\n        // but we need to check if we didn't cut too much of it off\n        // so we are changing the last splitting decision from splitting and going left\n        // to splitting and going right\n        this._splitDirectionSeq.splice(\n          this._splitDirectionSeq.length - 1,\n          1,\n          SPLIT.RIGHT,\n          SPLIT.LEFT,\n        );\n      } else {\n        this._splitDirectionSeq.push(SPLIT.LEFT);\n      }\n\n      this._tryToFit(this._origText, this._splitDirectionSeq);\n    }\n  }\n\n  componentWillUnmount() {\n    if (this.resizeObserver) {\n      this.resizeObserver.disconnect();\n    }\n\n    this._lineHeight = null;\n    this._origText = null;\n    this._latestThatFits = null;\n    this._splitDirectionSeq = [];\n  }\n\n  _truncate() {\n    if (this._fits()) {\n      // the whole text fits on the first try, no need to do anything else\n      this._shouldTruncate = false;\n\n      return;\n    }\n\n    this._latestThatFits = null;\n\n    this._truncateOriginalText();\n  }\n\n  _childrenElementWithRef(children) {\n    const child = React.Children.only(children);\n\n    return React.cloneElement(child, { ref: el => (this.el = el) });\n  }\n\n  _truncateOriginalText() {\n    this._endFound = false;\n    this._splitDirectionSeq = [SPLIT.LEFT];\n\n    this._tryToFit(this._origText, this._splitDirectionSeq);\n  }\n\n  /**\n   * Splits rootEl based on instructions and updates React's state with the returned element\n   * After React rerenders the new text, we'll check if the new text fits in componentDidUpdate\n   * @param  {ReactElement} rootEl - the original children element\n   * @param  {Array} splitDirections - list of SPLIT.RIGHT/LEFT instructions\n   */\n  _tryToFit(rootEl, splitDirections) {\n    if (!rootEl.props.children) {\n      // no markup in container\n      return;\n    }\n\n    const newRootEl = this._split(rootEl, splitDirections, /* isRootEl */ true);\n\n    const ellipsis =\n      typeof this.props.ellipsis === 'function'\n        ? this.props.ellipsis(newRootEl)\n        : typeof this.props.ellipsis === 'object'\n          ? React.cloneElement(this.props.ellipsis, { key: 'ellipsis' })\n          : this.props.ellipsis;\n\n    const newChildren = newRootEl.props.children;\n    const newChildrenWithEllipsis = Array.isArray(newChildren)\n      ? [...newChildren, ellipsis]\n      : [newChildren, ellipsis];\n\n    this.setState({\n      text: {\n        ...newRootEl,\n        props: {\n          ...newRootEl.props,\n          style: {\n            wordWrap: 'break-word',\n            ...newRootEl.props.style,\n          },\n          children: newChildrenWithEllipsis,\n        },\n      },\n    });\n  }\n\n  /**\n   * Splits JSX node based on its type\n   * @param  {null|string|Array|Object} node - JSX node\n   * @param  {Array} splitDirections - list of SPLIT.RIGHT/LEFT instructions\n   * @return {null|string|Array|Object} - split JSX node\n   */\n  _split(node, splitDirections, isRoot = false) {\n    if (!node) {\n      return node;\n    } else if (typeof node === 'string') {\n      return this._splitString(node, splitDirections);\n    } else if (Array.isArray(node)) {\n      return this._splitArray(node, splitDirections);\n    }\n\n    const newChildren = this._split(node.props.children, splitDirections);\n\n    return cloneWithChildren(node, newChildren, isRoot);\n  }\n\n  _splitString(string, splitDirections = []) {\n    if (!splitDirections.length) {\n      return string;\n    }\n\n    if (splitDirections.length && string.length === 1) {\n      // we are trying to split further but we have nowhere to go now\n      // that means we've already found the max subtree that fits the container\n      this._endFound = true;\n\n      return string;\n    }\n\n    const [splitDirection, ...restSplitDirections] = splitDirections;\n    const pivotIndex = Math.ceil(string.length / 2);\n\n    if (splitDirection === SPLIT.LEFT) {\n      const subString = string.substring(0, pivotIndex);\n\n      return this._splitString(subString, restSplitDirections);\n    }\n    const beforeString = string.substring(0, pivotIndex);\n    const afterString = string.substring(pivotIndex);\n\n    return beforeString + this._splitString(afterString, restSplitDirections);\n  }\n\n  _splitArray(array, splitDirections = []) {\n    if (!splitDirections.length) {\n      return array;\n    }\n\n    if (array.length === 1) {\n      const [item] = array;\n\n      if (typeof item === 'string') {\n        return [this._splitString(item, splitDirections)];\n      }\n      const { children } = item.props;\n\n      const newChildren = this._split(children, splitDirections);\n\n      return [cloneWithChildren(item, newChildren)];\n    }\n\n    const [splitDirection, ...restSplitDirections] = splitDirections;\n    const pivotIndex = Math.ceil(array.length / 2);\n\n    if (splitDirection === SPLIT.LEFT) {\n      const subArray = array.slice(0, pivotIndex);\n\n      return this._splitArray(subArray, restSplitDirections);\n    }\n    const beforeArray = array.slice(0, pivotIndex);\n    const afterArray = array.slice(pivotIndex);\n\n    return beforeArray.concat(\n      this._splitArray(afterArray, restSplitDirections),\n    );\n  }\n\n  _fits() {\n    const { lines: maxLines } = this.props;\n    const { height } = this.el.getBoundingClientRect();\n    const computedLines = Math.round(height / parseFloat(this._lineHeight));\n\n    if (process.env.NODE_ENV !== 'production' && computedLines <= 0) {\n      /* eslint-disable no-console */\n      console.warn(\n        `TruncateMarkup: number of currently rendered lines: ${computedLines}, not truncating...\nIt may be caused by target element not being visible at the time of computation.`,\n      );\n      /* eslint-enable */\n    }\n\n    return maxLines >= computedLines;\n  }\n\n  render() {\n    return this.state.text;\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","module.exports = __WEBPACK_EXTERNAL_MODULE_2__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"root\":\"React\",\"commonjs2\":\"react\",\"commonjs\":\"react\",\"amd\":\"react\"}\n// module id = 2\n// module chunks = 0","// Load in dependencies\nvar computedStyle = require('computed-style');\n\n/**\n * Calculate the `line-height` of a given node\n * @param {HTMLElement} node Element to calculate line height of. Must be in the DOM.\n * @returns {Number} `line-height` of the element in pixels\n */\nfunction lineHeight(node) {\n  // Grab the line-height via style\n  var lnHeightStr = computedStyle(node, 'line-height');\n  var lnHeight = parseFloat(lnHeightStr, 10);\n\n  // If the lineHeight did not contain a unit (i.e. it was numeric), convert it to ems (e.g. '2.3' === '2.3em')\n  if (lnHeightStr === lnHeight + '') {\n    // Save the old lineHeight style and update the em unit to the element\n    var _lnHeightStyle = node.style.lineHeight;\n    node.style.lineHeight = lnHeightStr + 'em';\n\n    // Calculate the em based height\n    lnHeightStr = computedStyle(node, 'line-height');\n    lnHeight = parseFloat(lnHeightStr, 10);\n\n    // Revert the lineHeight style\n    if (_lnHeightStyle) {\n      node.style.lineHeight = _lnHeightStyle;\n    } else {\n      delete node.style.lineHeight;\n    }\n  }\n\n  // If the lineHeight is in `pt`, convert it to pixels (4px for 3pt)\n  // DEV: `em` units are converted to `pt` in IE6\n  // Conversion ratio from https://developer.mozilla.org/en-US/docs/Web/CSS/length\n  if (lnHeightStr.indexOf('pt') !== -1) {\n    lnHeight *= 4;\n    lnHeight /= 3;\n  // Otherwise, if the lineHeight is in `mm`, convert it to pixels (96px for 25.4mm)\n  } else if (lnHeightStr.indexOf('mm') !== -1) {\n    lnHeight *= 96;\n    lnHeight /= 25.4;\n  // Otherwise, if the lineHeight is in `cm`, convert it to pixels (96px for 2.54cm)\n  } else if (lnHeightStr.indexOf('cm') !== -1) {\n    lnHeight *= 96;\n    lnHeight /= 2.54;\n  // Otherwise, if the lineHeight is in `in`, convert it to pixels (96px for 1in)\n  } else if (lnHeightStr.indexOf('in') !== -1) {\n    lnHeight *= 96;\n  // Otherwise, if the lineHeight is in `pc`, convert it to pixels (12pt for 1pc)\n  } else if (lnHeightStr.indexOf('pc') !== -1) {\n    lnHeight *= 16;\n  }\n\n  // Continue our computation\n  lnHeight = Math.round(lnHeight);\n\n  // If the line-height is \"normal\", calculate by font-size\n  if (lnHeightStr === 'normal') {\n    // Create a temporary node\n    var nodeName = node.nodeName;\n    var _node = document.createElement(nodeName);\n    _node.innerHTML = '&nbsp;';\n\n    // If we have a text area, reset it to only 1 row\n    // https://github.com/twolfson/line-height/issues/4\n    if (nodeName.toUpperCase() === 'TEXTAREA') {\n      _node.setAttribute('rows', '1');\n    }\n\n    // Set the font-size of the element\n    var fontSizeStr = computedStyle(node, 'font-size');\n    _node.style.fontSize = fontSizeStr;\n\n    // Remove default padding/border which can affect offset height\n    // https://github.com/twolfson/line-height/issues/4\n    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetHeight\n    _node.style.padding = '0px';\n    _node.style.border = '0px';\n\n    // Append it to the body\n    var body = document.body;\n    body.appendChild(_node);\n\n    // Assume the line height of the element is the height\n    var height = _node.offsetHeight;\n    lnHeight = height;\n\n    // Remove our child from the DOM\n    body.removeChild(_node);\n  }\n\n  // Return the calculated height\n  return lnHeight;\n}\n\n// Export lineHeight\nmodule.exports = lineHeight;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/line-height/lib/line-height.js\n// module id = 3\n// module chunks = 0","// This code has been refactored for 140 bytes\n// You can see the original here: https://github.com/twolfson/computedStyle/blob/04cd1da2e30fa45844f95f5cb1ac898e9b9ef050/lib/computedStyle.js\nvar computedStyle = function (el, prop, getComputedStyle) {\n  getComputedStyle = window.getComputedStyle;\n\n  // In one fell swoop\n  return (\n    // If we have getComputedStyle\n    getComputedStyle ?\n      // Query it\n      // TODO: From CSS-Query notes, we might need (node, null) for FF\n      getComputedStyle(el) :\n\n    // Otherwise, we are in IE and use currentStyle\n      el.currentStyle\n  )[\n    // Switch to camelCase for CSSOM\n    // DEV: Grabbed from jQuery\n    // https://github.com/jquery/jquery/blob/1.9-stable/src/css.js#L191-L194\n    // https://github.com/jquery/jquery/blob/1.9-stable/src/core.js#L593-L597\n    prop.replace(/-(\\w)/gi, function (word, letter) {\n      return letter.toUpperCase();\n    })\n  ];\n};\n\nmodule.exports = computedStyle;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/computed-style/dist/computedStyle.commonjs.js\n// module id = 4\n// module chunks = 0","/**\r\n * A collection of shims that provide minimal functionality of the ES6 collections.\r\n *\r\n * These implementations are not meant to be used outside of the ResizeObserver\r\n * modules as they cover only a limited range of use cases.\r\n */\r\n/* eslint-disable require-jsdoc, valid-jsdoc */\r\nvar MapShim = (function () {\r\n    if (typeof Map != 'undefined') {\r\n        return Map;\r\n    }\r\n\r\n    /**\r\n     * Returns index in provided array that matches the specified key.\r\n     *\r\n     * @param {Array<Array>} arr\r\n     * @param {*} key\r\n     * @returns {number}\r\n     */\r\n    function getIndex(arr, key) {\r\n        var result = -1;\r\n\r\n        arr.some(function (entry, index) {\r\n            if (entry[0] === key) {\r\n                result = index;\r\n\r\n                return true;\r\n            }\r\n\r\n            return false;\r\n        });\r\n\r\n        return result;\r\n    }\r\n\r\n    return (function () {\r\n        function anonymous() {\r\n            this.__entries__ = [];\r\n        }\r\n\r\n        var prototypeAccessors = { size: {} };\r\n\r\n        /**\r\n         * @returns {boolean}\r\n         */\r\n        prototypeAccessors.size.get = function () {\r\n            return this.__entries__.length;\r\n        };\r\n\r\n        /**\r\n         * @param {*} key\r\n         * @returns {*}\r\n         */\r\n        anonymous.prototype.get = function (key) {\r\n            var index = getIndex(this.__entries__, key);\r\n            var entry = this.__entries__[index];\r\n\r\n            return entry && entry[1];\r\n        };\r\n\r\n        /**\r\n         * @param {*} key\r\n         * @param {*} value\r\n         * @returns {void}\r\n         */\r\n        anonymous.prototype.set = function (key, value) {\r\n            var index = getIndex(this.__entries__, key);\r\n\r\n            if (~index) {\r\n                this.__entries__[index][1] = value;\r\n            } else {\r\n                this.__entries__.push([key, value]);\r\n            }\r\n        };\r\n\r\n        /**\r\n         * @param {*} key\r\n         * @returns {void}\r\n         */\r\n        anonymous.prototype.delete = function (key) {\r\n            var entries = this.__entries__;\r\n            var index = getIndex(entries, key);\r\n\r\n            if (~index) {\r\n                entries.splice(index, 1);\r\n            }\r\n        };\r\n\r\n        /**\r\n         * @param {*} key\r\n         * @returns {void}\r\n         */\r\n        anonymous.prototype.has = function (key) {\r\n            return !!~getIndex(this.__entries__, key);\r\n        };\r\n\r\n        /**\r\n         * @returns {void}\r\n         */\r\n        anonymous.prototype.clear = function () {\r\n            this.__entries__.splice(0);\r\n        };\r\n\r\n        /**\r\n         * @param {Function} callback\r\n         * @param {*} [ctx=null]\r\n         * @returns {void}\r\n         */\r\n        anonymous.prototype.forEach = function (callback, ctx) {\r\n            if ( ctx === void 0 ) ctx = null;\r\n\r\n            for (var i = 0, list = this.__entries__; i < list.length; i += 1) {\r\n                var entry = list[i];\r\n\r\n                callback.call(ctx, entry[1], entry[0]);\r\n            }\r\n        };\r\n\r\n        Object.defineProperties( anonymous.prototype, prototypeAccessors );\r\n\r\n        return anonymous;\r\n    }());\r\n})();\r\n\r\n/**\r\n * Detects whether window and document objects are available in current environment.\r\n */\r\nvar isBrowser = typeof window != 'undefined' && typeof document != 'undefined' && window.document === document;\r\n\r\n/**\r\n * A shim for the requestAnimationFrame which falls back to the setTimeout if\r\n * first one is not supported.\r\n *\r\n * @returns {number} Requests' identifier.\r\n */\r\nvar requestAnimationFrame$1 = (function () {\r\n    if (typeof requestAnimationFrame === 'function') {\r\n        return requestAnimationFrame;\r\n    }\r\n\r\n    return function (callback) { return setTimeout(function () { return callback(Date.now()); }, 1000 / 60); };\r\n})();\r\n\r\n// Defines minimum timeout before adding a trailing call.\r\nvar trailingTimeout = 2;\r\n\r\n/**\r\n * Creates a wrapper function which ensures that provided callback will be\r\n * invoked only once during the specified delay period.\r\n *\r\n * @param {Function} callback - Function to be invoked after the delay period.\r\n * @param {number} delay - Delay after which to invoke callback.\r\n * @returns {Function}\r\n */\r\nvar throttle = function (callback, delay) {\r\n    var leadingCall = false,\r\n        trailingCall = false,\r\n        lastCallTime = 0;\r\n\r\n    /**\r\n     * Invokes the original callback function and schedules new invocation if\r\n     * the \"proxy\" was called during current request.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    function resolvePending() {\r\n        if (leadingCall) {\r\n            leadingCall = false;\r\n\r\n            callback();\r\n        }\r\n\r\n        if (trailingCall) {\r\n            proxy();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Callback invoked after the specified delay. It will further postpone\r\n     * invocation of the original function delegating it to the\r\n     * requestAnimationFrame.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    function timeoutCallback() {\r\n        requestAnimationFrame$1(resolvePending);\r\n    }\r\n\r\n    /**\r\n     * Schedules invocation of the original function.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    function proxy() {\r\n        var timeStamp = Date.now();\r\n\r\n        if (leadingCall) {\r\n            // Reject immediately following calls.\r\n            if (timeStamp - lastCallTime < trailingTimeout) {\r\n                return;\r\n            }\r\n\r\n            // Schedule new call to be in invoked when the pending one is resolved.\r\n            // This is important for \"transitions\" which never actually start\r\n            // immediately so there is a chance that we might miss one if change\r\n            // happens amids the pending invocation.\r\n            trailingCall = true;\r\n        } else {\r\n            leadingCall = true;\r\n            trailingCall = false;\r\n\r\n            setTimeout(timeoutCallback, delay);\r\n        }\r\n\r\n        lastCallTime = timeStamp;\r\n    }\r\n\r\n    return proxy;\r\n};\r\n\r\n// Minimum delay before invoking the update of observers.\r\nvar REFRESH_DELAY = 20;\r\n\r\n// A list of substrings of CSS properties used to find transition events that\r\n// might affect dimensions of observed elements.\r\nvar transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight'];\r\n\r\n// Detect whether running in IE 11 (facepalm).\r\nvar isIE11 = typeof navigator != 'undefined' && /Trident\\/.*rv:11/.test(navigator.userAgent);\r\n\r\n// MutationObserver should not be used if running in Internet Explorer 11 as it's\r\n// implementation is unreliable. Example: https://jsfiddle.net/x2r3jpuz/2/\r\n//\r\n// It's a real bummer that there is no other way to check for this issue but to\r\n// use the UA information.\r\nvar mutationObserverSupported = typeof MutationObserver != 'undefined' && !isIE11;\r\n\r\n/**\r\n * Singleton controller class which handles updates of ResizeObserver instances.\r\n */\r\nvar ResizeObserverController = function() {\r\n    /**\r\n     * Indicates whether DOM listeners have been added.\r\n     *\r\n     * @private {boolean}\r\n     */\r\n    this.connected_ = false;\r\n\r\n    /**\r\n     * Tells that controller has subscribed for Mutation Events.\r\n     *\r\n     * @private {boolean}\r\n     */\r\n    this.mutationEventsAdded_ = false;\r\n\r\n    /**\r\n     * Keeps reference to the instance of MutationObserver.\r\n     *\r\n     * @private {MutationObserver}\r\n     */\r\n    this.mutationsObserver_ = null;\r\n\r\n    /**\r\n     * A list of connected observers.\r\n     *\r\n     * @private {Array<ResizeObserverSPI>}\r\n     */\r\n    this.observers_ = [];\r\n\r\n    this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);\r\n    this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);\r\n};\r\n\r\n/**\r\n * Adds observer to observers list.\r\n *\r\n * @param {ResizeObserverSPI} observer - Observer to be added.\r\n * @returns {void}\r\n */\r\nResizeObserverController.prototype.addObserver = function (observer) {\r\n    if (!~this.observers_.indexOf(observer)) {\r\n        this.observers_.push(observer);\r\n    }\r\n\r\n    // Add listeners if they haven't been added yet.\r\n    if (!this.connected_) {\r\n        this.connect_();\r\n    }\r\n};\r\n\r\n/**\r\n * Removes observer from observers list.\r\n *\r\n * @param {ResizeObserverSPI} observer - Observer to be removed.\r\n * @returns {void}\r\n */\r\nResizeObserverController.prototype.removeObserver = function (observer) {\r\n    var observers = this.observers_;\r\n    var index = observers.indexOf(observer);\r\n\r\n    // Remove observer if it's present in registry.\r\n    if (~index) {\r\n        observers.splice(index, 1);\r\n    }\r\n\r\n    // Remove listeners if controller has no connected observers.\r\n    if (!observers.length && this.connected_) {\r\n        this.disconnect_();\r\n    }\r\n};\r\n\r\n/**\r\n * Invokes the update of observers. It will continue running updates insofar\r\n * it detects changes.\r\n *\r\n * @returns {void}\r\n */\r\nResizeObserverController.prototype.refresh = function () {\r\n    var changesDetected = this.updateObservers_();\r\n\r\n    // Continue running updates if changes have been detected as there might\r\n    // be future ones caused by CSS transitions.\r\n    if (changesDetected) {\r\n        this.refresh();\r\n    }\r\n};\r\n\r\n/**\r\n * Updates every observer from observers list and notifies them of queued\r\n * entries.\r\n *\r\n * @private\r\n * @returns {boolean} Returns \"true\" if any observer has detected changes in\r\n *  dimensions of it's elements.\r\n */\r\nResizeObserverController.prototype.updateObservers_ = function () {\r\n    // Collect observers that have active observations.\r\n    var activeObservers = this.observers_.filter(function (observer) {\r\n        return observer.gatherActive(), observer.hasActive();\r\n    });\r\n\r\n    // Deliver notifications in a separate cycle in order to avoid any\r\n    // collisions between observers, e.g. when multiple instances of\r\n    // ResizeObserver are tracking the same element and the callback of one\r\n    // of them changes content dimensions of the observed target. Sometimes\r\n    // this may result in notifications being blocked for the rest of observers.\r\n    activeObservers.forEach(function (observer) { return observer.broadcastActive(); });\r\n\r\n    return activeObservers.length > 0;\r\n};\r\n\r\n/**\r\n * Initializes DOM listeners.\r\n *\r\n * @private\r\n * @returns {void}\r\n */\r\nResizeObserverController.prototype.connect_ = function () {\r\n    // Do nothing if running in a non-browser environment or if listeners\r\n    // have been already added.\r\n    if (!isBrowser || this.connected_) {\r\n        return;\r\n    }\r\n\r\n    // Subscription to the \"Transitionend\" event is used as a workaround for\r\n    // delayed transitions. This way it's possible to capture at least the\r\n    // final state of an element.\r\n    document.addEventListener('transitionend', this.onTransitionEnd_);\r\n\r\n    window.addEventListener('resize', this.refresh);\r\n\r\n    if (mutationObserverSupported) {\r\n        this.mutationsObserver_ = new MutationObserver(this.refresh);\r\n\r\n        this.mutationsObserver_.observe(document, {\r\n            attributes: true,\r\n            childList: true,\r\n            characterData: true,\r\n            subtree: true\r\n        });\r\n    } else {\r\n        document.addEventListener('DOMSubtreeModified', this.refresh);\r\n\r\n        this.mutationEventsAdded_ = true;\r\n    }\r\n\r\n    this.connected_ = true;\r\n};\r\n\r\n/**\r\n * Removes DOM listeners.\r\n *\r\n * @private\r\n * @returns {void}\r\n */\r\nResizeObserverController.prototype.disconnect_ = function () {\r\n    // Do nothing if running in a non-browser environment or if listeners\r\n    // have been already removed.\r\n    if (!isBrowser || !this.connected_) {\r\n        return;\r\n    }\r\n\r\n    document.removeEventListener('transitionend', this.onTransitionEnd_);\r\n    window.removeEventListener('resize', this.refresh);\r\n\r\n    if (this.mutationsObserver_) {\r\n        this.mutationsObserver_.disconnect();\r\n    }\r\n\r\n    if (this.mutationEventsAdded_) {\r\n        document.removeEventListener('DOMSubtreeModified', this.refresh);\r\n    }\r\n\r\n    this.mutationsObserver_ = null;\r\n    this.mutationEventsAdded_ = false;\r\n    this.connected_ = false;\r\n};\r\n\r\n/**\r\n * \"Transitionend\" event handler.\r\n *\r\n * @private\r\n * @param {TransitionEvent} event\r\n * @returns {void}\r\n */\r\nResizeObserverController.prototype.onTransitionEnd_ = function (ref) {\r\n        var propertyName = ref.propertyName;\r\n\r\n    // Detect whether transition may affect dimensions of an element.\r\n    var isReflowProperty = transitionKeys.some(function (key) {\r\n        return !!~propertyName.indexOf(key);\r\n    });\r\n\r\n    if (isReflowProperty) {\r\n        this.refresh();\r\n    }\r\n};\r\n\r\n/**\r\n * Returns instance of the ResizeObserverController.\r\n *\r\n * @returns {ResizeObserverController}\r\n */\r\nResizeObserverController.getInstance = function () {\r\n    if (!this.instance_) {\r\n        this.instance_ = new ResizeObserverController();\r\n    }\r\n\r\n    return this.instance_;\r\n};\r\n\r\n/**\r\n * Holds reference to the controller's instance.\r\n *\r\n * @private {ResizeObserverController}\r\n */\r\nResizeObserverController.instance_ = null;\r\n\r\n/**\r\n * Defines non-writable/enumerable properties of the provided target object.\r\n *\r\n * @param {Object} target - Object for which to define properties.\r\n * @param {Object} props - Properties to be defined.\r\n * @returns {Object} Target object.\r\n */\r\nvar defineConfigurable = (function (target, props) {\r\n    for (var i = 0, list = Object.keys(props); i < list.length; i += 1) {\r\n        var key = list[i];\r\n\r\n        Object.defineProperty(target, key, {\r\n            value: props[key],\r\n            enumerable: false,\r\n            writable: false,\r\n            configurable: true\r\n        });\r\n    }\r\n\r\n    return target;\r\n});\r\n\r\n// Placeholder of an empty content rectangle.\r\nvar emptyRect = createRectInit(0, 0, 0, 0);\r\n\r\n/**\r\n * Converts provided string to a number.\r\n *\r\n * @param {number|string} value\r\n * @returns {number}\r\n */\r\nfunction toFloat(value) {\r\n    return parseFloat(value) || 0;\r\n}\r\n\r\n/**\r\n * Extracts borders size from provided styles.\r\n *\r\n * @param {CSSStyleDeclaration} styles\r\n * @param {...string} positions - Borders positions (top, right, ...)\r\n * @returns {number}\r\n */\r\nfunction getBordersSize(styles) {\r\n    var positions = Array.prototype.slice.call(arguments, 1);\r\n\r\n    return positions.reduce(function (size, position) {\r\n        var value = styles['border-' + position + '-width'];\r\n\r\n        return size + toFloat(value);\r\n    }, 0);\r\n}\r\n\r\n/**\r\n * Extracts paddings sizes from provided styles.\r\n *\r\n * @param {CSSStyleDeclaration} styles\r\n * @returns {Object} Paddings box.\r\n */\r\nfunction getPaddings(styles) {\r\n    var positions = ['top', 'right', 'bottom', 'left'];\r\n    var paddings = {};\r\n\r\n    for (var i = 0, list = positions; i < list.length; i += 1) {\r\n        var position = list[i];\r\n\r\n        var value = styles['padding-' + position];\r\n\r\n        paddings[position] = toFloat(value);\r\n    }\r\n\r\n    return paddings;\r\n}\r\n\r\n/**\r\n * Calculates content rectangle of provided SVG element.\r\n *\r\n * @param {SVGGraphicsElement} target - Element content rectangle of which needs\r\n *      to be calculated.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction getSVGContentRect(target) {\r\n    var bbox = target.getBBox();\r\n\r\n    return createRectInit(0, 0, bbox.width, bbox.height);\r\n}\r\n\r\n/**\r\n * Calculates content rectangle of provided HTMLElement.\r\n *\r\n * @param {HTMLElement} target - Element for which to calculate the content rectangle.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction getHTMLElementContentRect(target) {\r\n    // Client width & height properties can't be\r\n    // used exclusively as they provide rounded values.\r\n    var clientWidth = target.clientWidth;\r\n    var clientHeight = target.clientHeight;\r\n\r\n    // By this condition we can catch all non-replaced inline, hidden and\r\n    // detached elements. Though elements with width & height properties less\r\n    // than 0.5 will be discarded as well.\r\n    //\r\n    // Without it we would need to implement separate methods for each of\r\n    // those cases and it's not possible to perform a precise and performance\r\n    // effective test for hidden elements. E.g. even jQuery's ':visible' filter\r\n    // gives wrong results for elements with width & height less than 0.5.\r\n    if (!clientWidth && !clientHeight) {\r\n        return emptyRect;\r\n    }\r\n\r\n    var styles = getComputedStyle(target);\r\n    var paddings = getPaddings(styles);\r\n    var horizPad = paddings.left + paddings.right;\r\n    var vertPad = paddings.top + paddings.bottom;\r\n\r\n    // Computed styles of width & height are being used because they are the\r\n    // only dimensions available to JS that contain non-rounded values. It could\r\n    // be possible to utilize the getBoundingClientRect if only it's data wasn't\r\n    // affected by CSS transformations let alone paddings, borders and scroll bars.\r\n    var width = toFloat(styles.width),\r\n        height = toFloat(styles.height);\r\n\r\n    // Width & height include paddings and borders when the 'border-box' box\r\n    // model is applied (except for IE).\r\n    if (styles.boxSizing === 'border-box') {\r\n        // Following conditions are required to handle Internet Explorer which\r\n        // doesn't include paddings and borders to computed CSS dimensions.\r\n        //\r\n        // We can say that if CSS dimensions + paddings are equal to the \"client\"\r\n        // properties then it's either IE, and thus we don't need to subtract\r\n        // anything, or an element merely doesn't have paddings/borders styles.\r\n        if (Math.round(width + horizPad) !== clientWidth) {\r\n            width -= getBordersSize(styles, 'left', 'right') + horizPad;\r\n        }\r\n\r\n        if (Math.round(height + vertPad) !== clientHeight) {\r\n            height -= getBordersSize(styles, 'top', 'bottom') + vertPad;\r\n        }\r\n    }\r\n\r\n    // Following steps can't be applied to the document's root element as its\r\n    // client[Width/Height] properties represent viewport area of the window.\r\n    // Besides, it's as well not necessary as the <html> itself neither has\r\n    // rendered scroll bars nor it can be clipped.\r\n    if (!isDocumentElement(target)) {\r\n        // In some browsers (only in Firefox, actually) CSS width & height\r\n        // include scroll bars size which can be removed at this step as scroll\r\n        // bars are the only difference between rounded dimensions + paddings\r\n        // and \"client\" properties, though that is not always true in Chrome.\r\n        var vertScrollbar = Math.round(width + horizPad) - clientWidth;\r\n        var horizScrollbar = Math.round(height + vertPad) - clientHeight;\r\n\r\n        // Chrome has a rather weird rounding of \"client\" properties.\r\n        // E.g. for an element with content width of 314.2px it sometimes gives\r\n        // the client width of 315px and for the width of 314.7px it may give\r\n        // 314px. And it doesn't happen all the time. So just ignore this delta\r\n        // as a non-relevant.\r\n        if (Math.abs(vertScrollbar) !== 1) {\r\n            width -= vertScrollbar;\r\n        }\r\n\r\n        if (Math.abs(horizScrollbar) !== 1) {\r\n            height -= horizScrollbar;\r\n        }\r\n    }\r\n\r\n    return createRectInit(paddings.left, paddings.top, width, height);\r\n}\r\n\r\n/**\r\n * Checks whether provided element is an instance of the SVGGraphicsElement.\r\n *\r\n * @param {Element} target - Element to be checked.\r\n * @returns {boolean}\r\n */\r\nvar isSVGGraphicsElement = (function () {\r\n    // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement\r\n    // interface.\r\n    if (typeof SVGGraphicsElement != 'undefined') {\r\n        return function (target) { return target instanceof SVGGraphicsElement; };\r\n    }\r\n\r\n    // If it's so, then check that element is at least an instance of the\r\n    // SVGElement and that it has the \"getBBox\" method.\r\n    // eslint-disable-next-line no-extra-parens\r\n    return function (target) { return target instanceof SVGElement && typeof target.getBBox === 'function'; };\r\n})();\r\n\r\n/**\r\n * Checks whether provided element is a document element (<html>).\r\n *\r\n * @param {Element} target - Element to be checked.\r\n * @returns {boolean}\r\n */\r\nfunction isDocumentElement(target) {\r\n    return target === document.documentElement;\r\n}\r\n\r\n/**\r\n * Calculates an appropriate content rectangle for provided html or svg element.\r\n *\r\n * @param {Element} target - Element content rectangle of which needs to be calculated.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction getContentRect(target) {\r\n    if (!isBrowser) {\r\n        return emptyRect;\r\n    }\r\n\r\n    if (isSVGGraphicsElement(target)) {\r\n        return getSVGContentRect(target);\r\n    }\r\n\r\n    return getHTMLElementContentRect(target);\r\n}\r\n\r\n/**\r\n * Creates rectangle with an interface of the DOMRectReadOnly.\r\n * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly\r\n *\r\n * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.\r\n * @returns {DOMRectReadOnly}\r\n */\r\nfunction createReadOnlyRect(ref) {\r\n    var x = ref.x;\r\n    var y = ref.y;\r\n    var width = ref.width;\r\n    var height = ref.height;\r\n\r\n    // If DOMRectReadOnly is available use it as a prototype for the rectangle.\r\n    var Constr = typeof DOMRectReadOnly != 'undefined' ? DOMRectReadOnly : Object;\r\n    var rect = Object.create(Constr.prototype);\r\n\r\n    // Rectangle's properties are not writable and non-enumerable.\r\n    defineConfigurable(rect, {\r\n        x: x, y: y, width: width, height: height,\r\n        top: y,\r\n        right: x + width,\r\n        bottom: height + y,\r\n        left: x\r\n    });\r\n\r\n    return rect;\r\n}\r\n\r\n/**\r\n * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.\r\n * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit\r\n *\r\n * @param {number} x - X coordinate.\r\n * @param {number} y - Y coordinate.\r\n * @param {number} width - Rectangle's width.\r\n * @param {number} height - Rectangle's height.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction createRectInit(x, y, width, height) {\r\n    return { x: x, y: y, width: width, height: height };\r\n}\r\n\r\n/**\r\n * Class that is responsible for computations of the content rectangle of\r\n * provided DOM element and for keeping track of it's changes.\r\n */\r\nvar ResizeObservation = function(target) {\r\n    /**\r\n     * Broadcasted width of content rectangle.\r\n     *\r\n     * @type {number}\r\n     */\r\n    this.broadcastWidth = 0;\r\n\r\n    /**\r\n     * Broadcasted height of content rectangle.\r\n     *\r\n     * @type {number}\r\n     */\r\n    this.broadcastHeight = 0;\r\n\r\n    /**\r\n     * Reference to the last observed content rectangle.\r\n     *\r\n     * @private {DOMRectInit}\r\n     */\r\n    this.contentRect_ = createRectInit(0, 0, 0, 0);\r\n\r\n    /**\r\n     * Reference to the observed element.\r\n     *\r\n     * @type {Element}\r\n     */\r\n    this.target = target;\r\n};\r\n\r\n/**\r\n * Updates content rectangle and tells whether it's width or height properties\r\n * have changed since the last broadcast.\r\n *\r\n * @returns {boolean}\r\n */\r\nResizeObservation.prototype.isActive = function () {\r\n    var rect = getContentRect(this.target);\r\n\r\n    this.contentRect_ = rect;\r\n\r\n    return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;\r\n};\r\n\r\n/**\r\n * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data\r\n * from the corresponding properties of the last observed content rectangle.\r\n *\r\n * @returns {DOMRectInit} Last observed content rectangle.\r\n */\r\nResizeObservation.prototype.broadcastRect = function () {\r\n    var rect = this.contentRect_;\r\n\r\n    this.broadcastWidth = rect.width;\r\n    this.broadcastHeight = rect.height;\r\n\r\n    return rect;\r\n};\r\n\r\nvar ResizeObserverEntry = function(target, rectInit) {\r\n    var contentRect = createReadOnlyRect(rectInit);\r\n\r\n    // According to the specification following properties are not writable\r\n    // and are also not enumerable in the native implementation.\r\n    //\r\n    // Property accessors are not being used as they'd require to define a\r\n    // private WeakMap storage which may cause memory leaks in browsers that\r\n    // don't support this type of collections.\r\n    defineConfigurable(this, { target: target, contentRect: contentRect });\r\n};\r\n\r\nvar ResizeObserverSPI = function(callback, controller, callbackCtx) {\r\n    if (typeof callback !== 'function') {\r\n        throw new TypeError('The callback provided as parameter 1 is not a function.');\r\n    }\r\n\r\n    /**\r\n     * Collection of resize observations that have detected changes in dimensions\r\n     * of elements.\r\n     *\r\n     * @private {Array<ResizeObservation>}\r\n     */\r\n    this.activeObservations_ = [];\r\n\r\n    /**\r\n     * Registry of the ResizeObservation instances.\r\n     *\r\n     * @private {Map<Element, ResizeObservation>}\r\n     */\r\n    this.observations_ = new MapShim();\r\n\r\n    /**\r\n     * Reference to the callback function.\r\n     *\r\n     * @private {ResizeObserverCallback}\r\n     */\r\n    this.callback_ = callback;\r\n\r\n    /**\r\n     * Reference to the associated ResizeObserverController.\r\n     *\r\n     * @private {ResizeObserverController}\r\n     */\r\n    this.controller_ = controller;\r\n\r\n    /**\r\n     * Public ResizeObserver instance which will be passed to the callback\r\n     * function and used as a value of it's \"this\" binding.\r\n     *\r\n     * @private {ResizeObserver}\r\n     */\r\n    this.callbackCtx_ = callbackCtx;\r\n};\r\n\r\n/**\r\n * Starts observing provided element.\r\n *\r\n * @param {Element} target - Element to be observed.\r\n * @returns {void}\r\n */\r\nResizeObserverSPI.prototype.observe = function (target) {\r\n    if (!arguments.length) {\r\n        throw new TypeError('1 argument required, but only 0 present.');\r\n    }\r\n\r\n    // Do nothing if current environment doesn't have the Element interface.\r\n    if (typeof Element === 'undefined' || !(Element instanceof Object)) {\r\n        return;\r\n    }\r\n\r\n    if (!(target instanceof Element)) {\r\n        throw new TypeError('parameter 1 is not of type \"Element\".');\r\n    }\r\n\r\n    var observations = this.observations_;\r\n\r\n    // Do nothing if element is already being observed.\r\n    if (observations.has(target)) {\r\n        return;\r\n    }\r\n\r\n    observations.set(target, new ResizeObservation(target));\r\n\r\n    this.controller_.addObserver(this);\r\n\r\n    // Force the update of observations.\r\n    this.controller_.refresh();\r\n};\r\n\r\n/**\r\n * Stops observing provided element.\r\n *\r\n * @param {Element} target - Element to stop observing.\r\n * @returns {void}\r\n */\r\nResizeObserverSPI.prototype.unobserve = function (target) {\r\n    if (!arguments.length) {\r\n        throw new TypeError('1 argument required, but only 0 present.');\r\n    }\r\n\r\n    // Do nothing if current environment doesn't have the Element interface.\r\n    if (typeof Element === 'undefined' || !(Element instanceof Object)) {\r\n        return;\r\n    }\r\n\r\n    if (!(target instanceof Element)) {\r\n        throw new TypeError('parameter 1 is not of type \"Element\".');\r\n    }\r\n\r\n    var observations = this.observations_;\r\n\r\n    // Do nothing if element is not being observed.\r\n    if (!observations.has(target)) {\r\n        return;\r\n    }\r\n\r\n    observations.delete(target);\r\n\r\n    if (!observations.size) {\r\n        this.controller_.removeObserver(this);\r\n    }\r\n};\r\n\r\n/**\r\n * Stops observing all elements.\r\n *\r\n * @returns {void}\r\n */\r\nResizeObserverSPI.prototype.disconnect = function () {\r\n    this.clearActive();\r\n    this.observations_.clear();\r\n    this.controller_.removeObserver(this);\r\n};\r\n\r\n/**\r\n * Collects observation instances the associated element of which has changed\r\n * it's content rectangle.\r\n *\r\n * @returns {void}\r\n */\r\nResizeObserverSPI.prototype.gatherActive = function () {\r\n        var this$1 = this;\r\n\r\n    this.clearActive();\r\n\r\n    this.observations_.forEach(function (observation) {\r\n        if (observation.isActive()) {\r\n            this$1.activeObservations_.push(observation);\r\n        }\r\n    });\r\n};\r\n\r\n/**\r\n * Invokes initial callback function with a list of ResizeObserverEntry\r\n * instances collected from active resize observations.\r\n *\r\n * @returns {void}\r\n */\r\nResizeObserverSPI.prototype.broadcastActive = function () {\r\n    // Do nothing if observer doesn't have active observations.\r\n    if (!this.hasActive()) {\r\n        return;\r\n    }\r\n\r\n    var ctx = this.callbackCtx_;\r\n\r\n    // Create ResizeObserverEntry instance for every active observation.\r\n    var entries = this.activeObservations_.map(function (observation) {\r\n        return new ResizeObserverEntry(observation.target, observation.broadcastRect());\r\n    });\r\n\r\n    this.callback_.call(ctx, entries, ctx);\r\n    this.clearActive();\r\n};\r\n\r\n/**\r\n * Clears the collection of active observations.\r\n *\r\n * @returns {void}\r\n */\r\nResizeObserverSPI.prototype.clearActive = function () {\r\n    this.activeObservations_.splice(0);\r\n};\r\n\r\n/**\r\n * Tells whether observer has active observations.\r\n *\r\n * @returns {boolean}\r\n */\r\nResizeObserverSPI.prototype.hasActive = function () {\r\n    return this.activeObservations_.length > 0;\r\n};\r\n\r\n// Registry of internal observers. If WeakMap is not available use current shim\r\n// for the Map collection as it has all required methods and because WeakMap\r\n// can't be fully polyfilled anyway.\r\nvar observers = typeof WeakMap != 'undefined' ? new WeakMap() : new MapShim();\r\n\r\n/**\r\n * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation\r\n * exposing only those methods and properties that are defined in the spec.\r\n */\r\nvar ResizeObserver$1 = function(callback) {\r\n    if (!(this instanceof ResizeObserver$1)) {\r\n        throw new TypeError('Cannot call a class as a function');\r\n    }\r\n\r\n    if (!arguments.length) {\r\n        throw new TypeError('1 argument required, but only 0 present.');\r\n    }\r\n\r\n    var controller = ResizeObserverController.getInstance();\r\n    var observer = new ResizeObserverSPI(callback, controller, this);\r\n\r\n    observers.set(this, observer);\r\n};\r\n\r\n// Expose public methods of ResizeObserver.\r\n['observe', 'unobserve', 'disconnect'].forEach(function (method) {\r\n    ResizeObserver$1.prototype[method] = function () {\r\n        return (ref = observers.get(this))[method].apply(ref, arguments);\r\n        var ref;\r\n    };\r\n});\r\n\r\nvar index = (function () {\r\n    // Export existing implementation if available.\r\n    if (typeof ResizeObserver != 'undefined') {\r\n        // eslint-disable-next-line no-undef\r\n        return ResizeObserver;\r\n    }\r\n\r\n    return ResizeObserver$1;\r\n})();\r\n\r\nexport default index;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js\n// module id = 5\n// module chunks = 0"],"sourceRoot":""}